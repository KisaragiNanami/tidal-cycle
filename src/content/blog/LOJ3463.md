---
title: LOJ3463 「WC2021」 表达式求值 题解
pubDate: 2023-10-23
tags:
  - DP
  - 树形DP
  - 计数
  - 表达式树
categories: 题解
description: 'Solution'
---

## Solution

先建立表达式树。

由于本题的表达式没有优先级之分，所以递归建树是比较方便的。

### Subtask 1~11

由于在运算中每个数是相对独立的，所以可以枚举每个数，计算其保留到最后的方案数。

设 $f(x,0/1/2)$ 为考虑表达式树上以 $x$ 为根的表达式，运算的结果小于/等于/大于 $x$ 的方案数。为了避免重复统计，对于一个值 $A_{i,j}$，我们认为只有 $A_{i,j} = A_{x,y}$ 并且 $x \le i$ 时才计入 $f(x,1)$。

然后做子树 $\min$、$\max$ 卷积即可。

复杂度 $O(nmE)$。

### Subtask 12~14

此时表达式只有一种结果，$\text{DFS}$ 时用`std::vector`暴力合并即可。

&nbsp;

下面是这两个部分分拼起来的代码，可以拿到 $70 \text{pts}$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define uint unsigned long long
#define PII pair<int,int>
#define MP make_pair
#define fi first
#define se second
#define pb push_back
#define eb emplace_back
#define SET(a,b) memset(a,b,sizeof(a))
#define CPY(a,b) memcpy(a,b,sizeof(b))
#define rep(i,j,k) for(int i=(j);i<=(k);++i)
#define per(i,j,k) for(int i=(j);i>=(k);--i)
int read() {
    int a=0, f=1; char c=getchar();
    while(!isdigit(c)) {
        if(c=='-') f=-1;
        c=getchar();
    }
    while(isdigit(c)) a=a*10+c-'0', c=getchar();
    return a*f;
}
const int N=5005, M=5e4+5, mod=1e9+7;
int n, m, len, a[12][N];
string s;
int tp, fg, st[M], match[M];
void getmatch() {
    rep(i,1,len) {
        if(s[i]=='?') fg=1;
        if(s[i]=='(') st[++tp]=i;
        else if(s[i]==')') {
            match[i]=st[tp];
            --tp;
        }
    }
}
int rt, cnt, ls[M], rs[M], pos[M];
void build(int& x,int l,int r) {
    if(l>r) return;
    if(!x) x=++cnt;
    if(l==r) {
        pos[x]=l;
        return;
    }
    if(s[r]==')') {
        pos[x]=match[r]-1;
        // printf("[%lld %lld] pos=%lld\n",l,r,pos[x]);
        build(ls[x],l,match[r]-2);
        build(rs[x],match[r]+1,r-1);
    } else {
        pos[x]=r-1;
        // printf("[%lld %lld] pos=%lld\n",l,r,pos[x]);
        build(ls[x],l,r-2);
        build(rs[x],r,r);
    }
}
namespace bf {
    int ans, ii, jj, f[M][3];
    void dfs(int x) {
        f[x][0]=f[x][1]=f[x][2]=0;
        if(!ls[x]) {
            int i=s[pos[x]]-'0'+1;        
            int v1=a[i][jj], v2=a[ii][jj];
            if(v1<v2) f[x][0]=1;
            else if(v1>v2) f[x][2]=1;
            else if(v1==v2&&i<=ii) f[x][1]=1;
            return;
        }
        dfs(ls[x]);
        dfs(rs[x]);
        if(s[pos[x]]=='<'||s[pos[x]]=='?') {
            rep(i,0,2) rep(j,0,2) {
                (f[x][min(i,j)]+=f[ls[x]][i]*f[rs[x]][j]%mod)%=mod;
            }
        }
        if(s[pos[x]]=='>'||s[pos[x]]=='?') {
            rep(i,0,2) rep(j,0,2) {
                (f[x][max(i,j)]+=f[ls[x]][i]*f[rs[x]][j]%mod)%=mod;
            }
        }
    }
    void solve() {
        rep(i,1,m) rep(j,1,n) {
            ii=i, jj=j;
            dfs(rt);
            (ans+=f[rt][1]*a[i][j]%mod)%=mod;
        }
        printf("%lld\n",ans);
    }
};
namespace sub1 {
    vector<int> dfs(int x) {
        if(!ls[x]) {
            int i=s[pos[x]]-'0'+1;
            vector<int> v(n+1);
            rep(j,1,n) v[j]=a[i][j];
            return v;
        }
        vector<int> v1=dfs(ls[x]), v2=dfs(rs[x]);
        if(s[pos[x]]=='>') {
            rep(i,1,n) v1[i]=max(v1[i],v2[i]);
        } else if(s[pos[x]]=='<') {
            rep(i,1,n) v1[i]=min(v1[i],v2[i]);
        }
        return v1;
    }
    void solve() {
        vector<int> v=dfs(rt);
        int ans=0;
        rep(i,1,n) (ans+=v[i])%=mod;
        printf("%lld\n",ans);
    }
}
signed main() {
    n=read(), m=read();
    rep(i,1,m) rep(j,1,n) {
        a[i][j]=read();
    }
    cin>>s;
    len=s.size();
    s=" "+s;
    getmatch();
    build(rt,1,len);
    // sub1::solve();
    if(fg) bf::solve(); else sub1::solve();
    return 0;
}
```

### Subtask 1~20

考虑一个转化：设结果为 $x$ 的方案数为 $G(x)$，结果 $\ge x$ 的方案数为 $F(x)$，那么有

$$
G(x) = F(x) - F(x+1)
$$



沿用 Subtask 1~11 的思路，不过我们要求的时大于等于某个值的方案数，这样似乎还是离不开枚举具体的值，减少不了 DP 的次数。考虑 $\min$ 和 $\max$ 不关心具体的值，而一列元素相对独立并且最多有 $2^m$ 种大小关系，我们可以枚举一个集合 $S$，设 $f(x,0/1)$ 为考虑以 $x$ 为根的表达式，其中最大值不是/是集合 $S$ 内元素的方案数。转移类似，最后记 $G(S) = f(root,1)$。

这样 DP 的复杂度就是 $O(2^m E)$。

然后枚举每个元素 $A_{i,j}$，求出第 $j$ 列的元素与它的大小关系（大于等于为 $1$，否则为 $0$），记得到的数为 $S_{i,j}$。答案就是

$$
\sum_{i=1}^n \sum_{j=1}^m \Big( G(S_{i,j}) - G(S_{i,j} \setminus \{j\}) \Big)
$$

总复杂度 $O(2^m E + nm^2)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define uint unsigned long long
#define PII pair<int,int>
#define MP make_pair
#define fi first
#define se second
#define pb push_back
#define eb emplace_back
#define SET(a,b) memset(a,b,sizeof(a))
#define CPY(a,b) memcpy(a,b,sizeof(b))
#define rep(i,j,k) for(int i=(j);i<=(k);++i)
#define per(i,j,k) for(int i=(j);i>=(k);--i)
int read() {
    int a=0, f=1; char c=getchar();
    while(!isdigit(c)) {
        if(c=='-') f=-1;
        c=getchar();
    }
    while(isdigit(c)) a=a*10+c-'0', c=getchar();
    return a*f;
}
const int N=5e4+5, M=5e4+5, mod=1e9+7;
int n, m, len, a[12][N];
string s;
int tp, fg, st[M], match[M];
void getmatch() {
    rep(i,1,len) {
        if(s[i]=='?') fg=1;
        if(s[i]=='(') st[++tp]=i;
        else if(s[i]==')') {
            match[i]=st[tp];
            --tp;
        }
    }
}
int rt, cnt, ls[M], rs[M], pos[M];
void build(int& x,int l,int r) {
    if(l>r) return;
    if(!x) x=++cnt;
    if(l==r) {
        pos[x]=l;
        return;
    }
    if(s[r]==')') {
        pos[x]=match[r]-1;
        // printf("[%lld %lld] pos=%lld\n",l,r,pos[x]);
        build(ls[x],l,match[r]-2);
        build(rs[x],match[r]+1,r-1);
    } else {
        pos[x]=r-1;
        // printf("[%lld %lld] pos=%lld\n",l,r,pos[x]);
        build(ls[x],l,r-2);
        build(rs[x],r,r);
    }
}
namespace sol {
    int ans, S, U, f[N][2], g[(1<<10)+5];
    void dfs(int x) {
        // printf("x=%lld\n",x);
        // if(!x) return;
        f[x][0]=f[x][1]=0;
        if(!ls[x]) {
            int t=(S>>(s[pos[x]]-'0'))&1;
            f[x][t]=1;
            return;
        }
        dfs(ls[x]);
        dfs(rs[x]);
        if(s[pos[x]]=='<') {
            rep(i,0,1) rep(j,0,1) {
                (f[x][min(i,j)]+=f[ls[x]][i]*f[rs[x]][j]%mod)%=mod;
            }
        }
        else if(s[pos[x]]=='>') {
            rep(i,0,1) rep(j,0,1) {
                (f[x][max(i,j)]+=f[ls[x]][i]*f[rs[x]][j]%mod)%=mod;
            }
        } else if(s[pos[x]]=='?') {
            rep(i,0,1) rep(j,0,1) {
                (f[x][max(i,j)]+=f[ls[x]][i]*f[rs[x]][j]%mod)%=mod;
                (f[x][min(i,j)]+=f[ls[x]][i]*f[rs[x]][j]%mod)%=mod;
                // (f[x][0]+=f[ls[x]][i]*f[rs[x]][j]%mod)%=mod;
                // if(i||j) (f[x][1]+=f[ls[x]][i]*f[rs[x]][j]%mod)%=mod;
            }
        }
    }
    void solve() {
        U=(1<<m)-1;
        for(;S<=U;++S) {
            dfs(rt);
            g[S]=f[rt][1];
            // printf("g[%lld]=%lld\n",S,g[S]);
        }
        rep(i,1,m) rep(j,1,n) {
            int S=0;
            rep(k,1,m) if(a[i][j]<a[k][j]||(a[i][j]==a[k][j]&&k>=i)) S|=(1<<(k-1));
            (ans+=(g[S]-g[S^(1<<(i-1))]+mod)%mod*a[i][j]%mod)%=mod;
        }
        printf("%lld\n",ans);
    }
};
signed main() {
    n=read(), m=read();
    rep(i,1,m) rep(j,1,n) {
        a[i][j]=read();
    }
    cin>>s;
    len=s.size();
    s=" "+s;
    getmatch();
    build(rt,1,len);
    sol::solve();
    // sub1::solve();
    // if(fg) bf::solve(); else sub1::solve();
    return 0;
}
```
