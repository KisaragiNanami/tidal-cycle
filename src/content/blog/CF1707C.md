---
title: CF1707C DFS Trees 题解
pubDate: 2023-09-07
tags:
  - 图论
  - 树论
  - 树上倍增
categories: 题解
description: 'Solution'
---



考虑这个算法什么时候会假掉。

如果这样选出的一条边 $(x,y)$ 不在 MST 中，那么说明此时 $x$ 与 $y$ 已经连通，也就说这条边是 MST 上的返祖边。

直接考虑以每个节点为根，是否会选出 MST 上的返祖边并不容易。我们尝试从每条边入手，考虑以哪些节点为根时，这条边会成为返祖边。

由于边权各不相同，所以 MST 唯一。我们先把 MST 求出来，设其为 $T$，随便定一个根。

考虑每一条非 MST 边 $(x,y)$，钦定 $\text{dep}(x) \ge \text{dep}(y)$，$z = \text{LCA}(x,y)$。

- 如果 $z \neq y$，那么只有以 $\text{subtree}(x)$ 或 $\text{subtree}(y)$ 中的节点为根时，才会使得这条边被错误地加入 MST。
- 如果 $z = y$，那么就是 $\text{subtree}(x)$ 中的节点，以及 $T - \text{subtree}\Big(son_x(y)\Big)$ 中的节点。

其中 $son_x(y)$ 表示 $y$ 一个子节点，满足其所在子树包含 $x$。

那么从 $x$ 执行算法，能求出 MST 的充要条件是 $x$ 被上述每一条边都统计到一次。

问题转化为子树加，单点查，再转化一下就是单点加，求树上前缀和。

$son_x(y)$ 可以用倍增轻松找到。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define uint unsigned long long
#define PII pair<int,int>
#define MP make_pair
#define fi first
#define se second
#define pb push_back
#define eb emplace_back
#define SET(a,b) memset(a,b,sizeof(a))
#define CPY(a,b) memcpy(a,b,sizeof(b))
#define rep(i,j,k) for(int i=(j);i<=(k);++i)
#define per(i,j,k) for(int i=(j);i>=(k);--i)
int read() {
    int a=0, f=1; char c=getchar();
    while(!isdigit(c)) {
        if(c=='-') f=-1;
        c=getchar();
    }
    while(isdigit(c)) a=a*10+c-'0', c=getchar();
    return a*f;
}
const int N=1e5+5;
int n, m, v[N<<1], f[N][17], dep[N], c[N];
vector<int> p[N];
struct node {
    int x, y, z;
    bool operator<(node b) {
        return z<b.z;
    }
} e[N<<1];
struct DSU {
    int fa[N];
    void init() { rep(i,1,n) fa[i]=i; }
    int get(int x) { return x==fa[x]? x:fa[x]=get(fa[x]); }
} dsu;
void kruskal() {
    sort(e+1,e+m+1);
    dsu.init();
    int cnt=0;
    rep(i,1,m) {
        int x=dsu.get(e[i].x), y=dsu.get(e[i].y);
        if(x!=y) {
            v[i]=1;
            dsu.fa[x]=y;
            // if(++cnt==n-1) break;
        }
    }
}
void build() {
    rep(i,1,m) if(v[i]) {
        int x=e[i].x, y=e[i].y;
        p[x].pb(y), p[y].pb(x);
    }
}
void dfs(int x,int fa) {
    dep[x]=dep[fa]+1;
    f[x][0]=fa;
    for(int i=1;i<=16;++i) f[x][i]=f[f[x][i-1]][i-1];
    for(auto y:p[x]) if(y!=fa) {
        dfs(y,x);
    }
}
int lca(int x,int y) {
    if(dep[x]<dep[y]) swap(x,y);
    for(int i=16;~i;--i) if (dep[f[x][i]]>=dep[y]) x=f[x][i];
    if(x==y) return x;
    for(int i=16;~i;--i) if(f[x][i]!=f[y][i]) x=f[x][i], y=f[y][i];
    return f[x][0];
}
void dfs2(int x,int fa) {
    for(auto y:p[x]) if(y!=fa) {
        c[y]+=c[x];
        dfs2(y,x);
    }
}
signed main() {
    n=read(), m=read();
    rep(i,1,m) {
        e[i].x=read(), e[i].y=read(), e[i].z=i;
    }
    kruskal();
    build();
    dfs(1,0);
    rep(i,1,m) if(!v[i]) {
        int x=e[i].x, y=e[i].y;
        if(dep[x]<dep[y]) swap(x,y);
        int z=lca(x,y);
        if(z==y) {
            ++c[1], ++c[x];
            int t=x;
            for(int j=16;~j;--j) if(dep[f[t][j]]>dep[y]) t=f[t][j];
            --c[t]; 
        } else ++c[x], ++c[y];
    }
    dfs2(1,0);
    rep(i,1,n) if(c[i]==m-n+1) putchar('1'); else putchar('0');
    return 0;
}

```


