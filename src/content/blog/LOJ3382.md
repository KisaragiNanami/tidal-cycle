---
title: LOJ#3382 「CSP-S 2020」 贪吃蛇 题解
pubDate: 2023-09-15 21:40:03
urls: loj3382-solution
tags:
  - 博弈论
  - 单调队列
categories: 题解
math: true
comment: true
---

## 题外话

虽然博弈论在大纲 NOI 级一栏中，但是只有 nim 博弈和 SG 函数。

所以这题算不算博弈论呢？

## Solution

首先明确每条蛇的策略：**在自己不死的前提下，尽可能多地吃掉别的蛇**。

也就是说，蛇的根本目的是**自己不死**。在此基础上，每条蛇都想要吃掉最多的蛇。

不妨称实力最强的蛇为「决策蛇」，实力最弱的蛇为「被决策蛇」。游戏的决定权只掌握在当前的决策蛇手中。

我们由浅入深地分析决策蛇的行动逻辑。

最显然的一点就是：如果决策蛇干掉被决策蛇后，自己成为了最弱的，那么它就一定不会这样做。

那么只要自己不会成为最弱的，就一定会干掉被决策蛇，得到 $1$ 的收益吗？不一定，因为如果在后面的过程中成为最弱的蛇，这样做的代价就是**死亡**。而这个代价是大于**一切收益**的，因此不能贪心能吃就吃。

想到这里，似乎陷入了僵局，决策蛇的行为似乎和场上的局面有关。

然而我们始终忽略了一点：虽然每条蛇都是绝顶聪明，但它们都是**自私**的。比起干掉曾经辉煌的决策蛇，它们更关心**自己能不能活到最后**。换句话说：成为被决策蛇后不一定会直接被干掉，如果当前决策蛇知道干掉被决策蛇后自己也没有好下场，那么它就不会这样做。

那么每一次决策蛇干掉被决策蛇，都相当于在赌，赌自己成为被决策蛇之后，那时决策蛇害怕自己死掉，从而不敢干掉它，选择结束游戏。

现在我们来考虑这样一个问题：如果决策蛇干掉被决策蛇之后不会成为最弱的蛇，博弈的环境对决策蛇来说是更好了，还是更差了？

排除掉它再次成为决策蛇的情况（收益净增加 $1$）。对于新的决策蛇，被决策蛇必然比先前更强，自己比先前的决策蛇更弱，那么强度小于自己的那些蛇对自己的威胁更大，从而博弈的环境更差了。当前决策蛇比先前决策蛇更难做出抉择：干掉被决策蛇，先前决策蛇就多了一个垫背的，后面的再选择干掉，那么就更难死；结束游戏，那么先前决策蛇收益净增加 $1$，正中其下怀。关键是自己更容易死。

这个有什么意义呢？就是如果决策蛇干掉被决策蛇之后，不会成为最弱的蛇，那么是有**正收益**的。所以如果出现这种情况，那么我们就选择干掉被决策蛇。



然而知道这么多后我们还还是不能做题。

问题出在哪呢？我们还缺少终止条件，即什么时候决策蛇会选择停下来。所以，真正的答案出现在「决策蛇干掉被决策蛇后，自己成为最弱的蛇」时，不妨称之为**临界局面**。

但是决策蛇不一定会在此时直接选择停下来，它还会尝试与下一条决策蛇博弈——看你有没有这个胆量吃掉我！

不过决策蛇不是赌徒，它会预测接下来的局面。

什么时候决策蛇会大胆干掉被决策蛇呢？

1. 只有两条蛇。
2. 干掉被决策蛇后，自己不会成为最弱的蛇。

我们尝试放到博弈图上去分析，不过在这种情景中，博弈图退化为链。

把上述情况看成是链的无出度点，然后剩下的点都是**临界局面**。

不难发现，对于无出度点的前继节点，决策蛇都不会干掉被决策蛇，否则自己就没了。然后对于它的前继节点，决策蛇抓住后继决策蛇的这种心理，就会放心大胆地干掉被决策蛇。再往前，决策蛇又会忌惮它的后继决策蛇，从而选择结束……

容易得到结论：在博弈图上，只有一个临界局面对应的节点，与这条链的无出度点距离奇数个点时，才会选择干掉当前决策蛇，然后下一条决策蛇会停止博弈；否则它会选择结束。



如何实现呢？用`std::set`维护每一条蛇，暴力模拟这个过程。遇到临界局面就暴力在博弈图上往下递归，回溯时记录距离奇偶性即可。

时间复杂度 $O( Tn \log_2 n)$，在 LOJ 上勉强通过。

这还不是正解，还可以挖掘单调性，用两个双端队列来维护所有蛇，可以做到 $O(Tn)$。

不过没必要写这个，所以先咕咕咕了。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define uint unsigned long long
#define PII pair<int,int>
#define MP make_pair
#define fi first
#define se second
#define pb push_back
#define eb emplace_back
#define SET(a,b) memset(a,b,sizeof(a))
#define CPY(a,b) memcpy(a,b,sizeof(b))
#define rep(i,j,k) for(int i=(j);i<=(k);++i)
#define per(i,j,k) for(int i=(j);i>=(k);--i)
int read() {
    int a=0, f=1; char c=getchar();
    while(!isdigit(c)) {
        if(c=='-') f=-1;
        c=getchar();
    }
    while(isdigit(c)) a=a*10+c-'0', c=getchar();
    return a*f;
}
const int N=1e6+5;
int T, n, a[N];
set<PII > s;
int oishi() {
    if(s.size()==2) return 1;
    auto mx=--s.end(), mn=s.begin();
    auto mn2=++s.begin();
    int d=mx->fi-mn->fi;
    if(d>mn2->fi||(d==mn2->fi&&mx->se>mn2->se)) {
        return 1;
    }
    s.erase(mx);
    s.erase(mn);
    s.insert({d,mx->se});
    return !oishi();
}
void solve() {
    s.clear();
    rep(i,1,n) s.insert({a[i],i});
    int ans=0;
    while(1) {
        if(s.size()==2) {
            ans=1;
            break;
        }
        auto mx=--s.end(), mn=s.begin();
        auto mn2=++s.begin();
        int d=mx->fi-mn->fi;
        if(d>mn2->fi||(d==mn2->fi&&mx->se>mn2->se)) {
            s.erase(mx);
            s.erase(mn);
            s.insert({d,mx->se});
        } else {
            ans=s.size();
            if(oishi()) --ans;
            break;
        }
    }
    printf("%d\n",ans);
}
signed main() {
    freopen("snakes.in","r",stdin);
    freopen("snakes.out","w",stdout);
    T=read();
    rep(i,1,T) {
        if(i==1) {
            n=read();
            rep(i,1,n) a[i]=read();
        } else {
            int k=read();
            while(k--) {
                int x=read(), y=read();
                a[x]=y;
            }
        }
        solve();
    }
    return 0;
}
```
