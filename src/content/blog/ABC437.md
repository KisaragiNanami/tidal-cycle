---
title: AtCoder Beginner Contest 437
tags:
  - 贪心
  - Trie
  - 树论
categories:
  - 比赛
  - atcoder
pubDate: 2026-01-01
description: '个人题解'
---

## A

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int,int> PII;
#define MP make_pair
#define fi first
#define se second
#define pb push_back
#define eb emplace_back
#define SET(a,b) memset(a,b,sizeof(a))
#define CPY(a,b) memcpy(a,b,sizeof(b))
#define rep(i,j,k) for(int i=(j);i<=(k);++i)
#define per(i,j,k) for(int i=(j);i>=(k);--i)
int read() {
   int a=0, f=1; char c=getchar();
   while(!isdigit(c)) {
       if(c=='-') f=-1;
       c=getchar();
   }
   while(isdigit(c)) a=a*10+c-'0', c=getchar();
   return a*f;
}
signed main() {
   ios::sync_with_stdio(0);
   cin.tie(0);
   cout.tie(0);
    int a, b;
    cin >> a >> b;
    cout << a * 12 + b << endl;
    return 0;
}
```
## B

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int,int> PII;
#define MP make_pair
#define fi first
#define se second
#define pb push_back
#define eb emplace_back
#define SET(a,b) memset(a,b,sizeof(a))
#define CPY(a,b) memcpy(a,b,sizeof(b))
#define rep(i,j,k) for(int i=(j);i<=(k);++i)
#define per(i,j,k) for(int i=(j);i>=(k);--i)
int read() {
   int a=0, f=1; char c=getchar();
   while(!isdigit(c)) {
       if(c=='-') f=-1;
       c=getchar();
   }
   while(isdigit(c)) a=a*10+c-'0', c=getchar();
   return a*f;
}
int n, m, k;
int a[105][105], v[105];
signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin >> n >> m >> k;
    for(int i = 1;i <= n;i++) {
        for(int j = 1;j <= m;j++) {
            cin >> a[i][j];
        }
    }
    for(int i = 1;i <= k;i++) {
        int x;
        cin >> x;
        v[x] = 1;
    }
    int ans = 0;
    for(int i = 1;i <= n;i++) {
        int res = 0;
        for(int j = 1;j <= m;j++) {
            res += v[a[i][j]];
        }
        ans = max(ans, res);
    }
    cout << ans << endl;
    return 0;
}
```

## C

设乘坐集合为 $A$，拉车集合为 $B$，要求

$$
\sum_{i \in A} w_i = sw \le \sum_{i \in B} p_i = sp
$$

既然找不到合适的方式直接贪心选择，尝试交换 $i \in A$ 与 $j \in B$。

有

$$
sw - w_i + w_j \le sp - p_j + p_i
\\
sw - (w_i + p_i) \le sp - (w_j + p_j)
$$

前者尽可能大，后者尽可能小时最优，于是按照 $w_i + p_i$ 为权值排序，当 $A$ 中所有元素的权值都小于 $B$ 中元素时一定最优秀。

还要有 $sw \le sp$


要最大化 $|A|$。假定所有元素一开始都属于 $A$，贪心地把 $w_i + p_i$ 最大的一些元素给 $B$，当 $sw \le sp$ 时停止，一定最优。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int,int> PII;
#define MP make_pair
#define fi first
#define se second
#define pb push_back
#define eb emplace_back
#define SET(a,b) memset(a,b,sizeof(a))
#define CPY(a,b) memcpy(a,b,sizeof(b))
#define rep(i,j,k) for(int i=(j);i<=(k);++i)
#define per(i,j,k) for(int i=(j);i>=(k);--i)
int read() {
   int a=0, f=1; char c=getchar();
   while(!isdigit(c)) {
       if(c=='-') f=-1;
       c=getchar();
   }
   while(isdigit(c)) a=a*10+c-'0', c=getchar();
   return a*f;
}
const int N = 3e5 + 5;
int T, n;
struct node {
    int w, p;
    bool operator<(const node& rsh) const {
        return w + p < rsh.w + rsh.p;
    }
} a[N], b[N];
bool cmp(node& a, node& b) {
    if(a.p != b.p) return a.p < b.p;
    return a.w < b.w;
}
void solve() {
    cin >> n;
    for(int i = 1;i <= n;i++) {
        cin >> a[i].w >> a[i].p;
    }
    sort(a + 1, a + n + 1);
    ll sp = 0, sw = 0;
    for(int i = 1;i <= n;i++) {
        sw += a[i].w;
    }
    for(int i = n;i;i--) {
        sp += a[i].p;
        sw -= a[i].w;
        if(sp >= sw) {
            cout << i - 1 << endl;
            return;
        }
    }
}
signed main() {
    cin >> T;
    while(T--) solve();
    return 0;
}
```

## D

答案与顺序无关，拆开绝对值，排序后找到临界点，然后前缀和搞一下就行。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int,int> PII;
#define MP make_pair
#define fi first
#define se second
#define pb push_back
#define eb emplace_back
#define SET(a,b) memset(a,b,sizeof(a))
#define CPY(a,b) memcpy(a,b,sizeof(b))
#define rep(i,j,k) for(int i=(j);i<=(k);++i)
#define per(i,j,k) for(int i=(j);i>=(k);--i)
int read() {
   int a=0, f=1; char c=getchar();
   while(!isdigit(c)) {
       if(c=='-') f=-1;
       c=getchar();
   }
   while(isdigit(c)) a=a*10+c-'0', c=getchar();
   return a*f;
}
const int mod = 998244353, N = 3e5 + 5;
int n, m, a[N], b[N];
int up[N];
ll sa[N], sb[N];
signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin >> n >> m;
    for(int i = 1;i <= n;i++) {
        cin >> a[i];
    }
    a[n + 1] = mod;
    for(int i = 1;i <= m;i++) {
        cin >> b[i];
    }
    sort(a + 1, a + n + 1);
    sort(b + 1, b + m + 1);
    for(int i = 1;i <= n;i++) sa[i] = (sa[i - 1] + a[i] + mod) % mod;
    int pos = 1;
    for(int i = 1;i <= m;i++) {
        while(pos <= n && a[pos] < b[i]) ++pos;
        up[i] = pos;
        // cout << up[i] << " ";
    }
    // cout << endl;
    ll ans = 0;
    for(int i = 1;i <= m;i++) {
        // if(up[i] != n + 1) {
            ans += ((sa[n] - sa[up[i] - 1] + mod) % mod  - 1ll * (n - up[i] + 1) * b[i] %mod + mod) %mod;
            ans %= mod;
            ans += (1ll * (up[i] - 1) * b[i] %mod - sa[up[i] - 1] + mod) %mod;
            ans %= mod;
        // }
        // 18 - 4 = 14
        // 15 - 6 + 6 - 3 = 12
    }
    cout << ans << endl;
    return 0;
}
```

## E

这个很容易抽象出一个类似字典树的东西，然而有个问题就是存在一些节点，它们代表的东西相同，它们是要一起输出的，但 DFS 无法做到，所以必须合并这些点。

建立字典树，然后用`std::map`来维护节点代表的字符串，然后把在本质不同节点间连边，相同节点的编号可以挂在代表节点上，用`std::vector`即可。

最后跑一遍 DFS，一次性输出挂着的所有节点就行。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int,int> PII;
#define MP make_pair
#define fi first
#define se second
#define pb push_back
#define eb emplace_back
#define SET(a,b) memset(a,b,sizeof(a))
#define CPY(a,b) memcpy(a,b,sizeof(b))
#define rep(i,j,k) for(int i=(j);i<=(k);++i)
#define per(i,j,k) for(int i=(j);i>=(k);--i)
int read() {
   int a=0, f=1; char c=getchar();
   while(!isdigit(c)) {
       if(c=='-') f=-1;
       c=getchar();
   }
   while(isdigit(c)) a=a*10+c-'0', c=getchar();
   return a*f;
}
const int N = 3e5 + 5;
int n, bel[N];
vector<int> apd[N], ans;
int tot;
map<int, int> trie[N];
void dfs(int x) {
    for(auto z : apd[x]) {
        ans.pb(z);
    }
    for(auto [s, y] : trie[x]) {
        dfs(y);
    }
}
signed main() {
    ios::sync_with_stdio(0);    
    cin.tie(0);
    cout.tie(0);
    cin >> n;
    bel[0] = 0;
    for(int i = 1;i <= n;i++) {
        int x, s;
        cin >> x >> s;
        if(!trie[bel[x]].count(s)) trie[bel[x]][s] = ++tot;
        bel[i] = trie[bel[x]][s];
        apd[bel[i]].pb(i);
    }
    dfs(0);
    for(auto x : ans) cout << x << " ";
    cout << endl;
    return 0;
}
```

## F

todo

## G

...