---
title: CF607D Power Tree 题解
pubDate: 2023-11-16
tags:
  - 树论
  - 线段树
categories:
  - 题解
description: 'Solution'
---
更新于 11/12/2025.

## Solution

容易写出来

$$
f(x) = \Big(|son(x)| + 1\Big) \times \Big( \sum_{y \in son(x)} f(y) + v_x \Big)
$$

这个不好动态维护，因为每产生一个叶子都会影响一条链的答案，链上问题并不好做。


考虑 $f(x)$ 的实际意义。

写出来就是

$$
f(x) = \sum_{y \in \text{subtree}(x)} w_y \prod_{z \in (x \rightarrow y)} rsz(x)
$$

其中 $rsz(x) = |son(x)| + 1$

容易想到把 $(x \rightarrow y)$ 这条链差分掉，由于模数是 $10^9+7$ 所以存在乘法逆元，那么

$$
f(x) = \sum_{y \in \text{subtree}(x)} w_y \frac{\prod_{z \in (1 \rightarrow y)} rsz(z)}{\prod_{z \in (1 \rightarrow fa_x)} rsz(z)}
$$

设 $pre_x = \prod_{y \in (1 \rightarrow x)} rsz(y)$，得到

$$
f(x) = \frac{1}{pre_{fa_x}} \sum_{y \in \text{subtree}(x)} w_y \times pre_{y}
$$

把点拍到 $\text{DFS}$ 序上，用线段树就能轻松维护。

但最大的问题是，加点会导致 $dfn$ 序列的改变。这种情况下我们只能尝试先把完整的森林建立起来，然后通过一些方式让没建立的点不产生贡献。加的点为 $x$ 时，$rsz(fa_x)$ 发生变化，受影响的只有 $\text{subtree}(fa_x)$。具体地，子树内的所有点都要乘上 $\frac{rsz(fa_x)+1}{rsz(fa_x)}$，也就是只有区间乘法操作。那么只需要在节点 $u$ 建立之前保持对应值为 $0$，建立时给对应位置加上 $w_u$ 即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define uint unsigned long long
#define PII pair<int,int>
#define MP make_pair
#define fi first
#define se second
#define pb push_back
#define eb emplace_back
#define SET(a,b) memset(a,b,sizeof(a))
#define CPY(a,b) memcpy(a,b,sizeof(b))
#define rep(i,j,k) for(int i=(j);i<=(k);++i)
#define per(i,j,k) for(int i=(j);i>=(k);--i)
int read() {
    int a=0, f=1; char c=getchar();
    while(!isdigit(c)) {
        if(c=='-') f=-1;
        c=getchar();
    }
    while(isdigit(c)) a=a*10+c-'0', c=getchar();
    return a*f;
}
const int N=2e5+5, mod=1e9+7;
int n, q, w[N], rsz[N];
int num, dfn[N], sz[N], fa[N];
int node[N], op[N];
vector<int> p[N];
int fp(int a,int b) {
    int c=1;
    for(;b;a=a*a%mod,b>>=1) {
        if(b&1) c=c*a%mod;
    }
    return c;
}
void dfs(int x,int fat) {
    fa[x]=fat;
    sz[x]=1;
    dfn[x]=++num;
    for(auto y:p[x]) if(y!=fat) {
        dfs(y,x);
        sz[x]+=sz[y];
    }
}
int t[N<<2], tag[N<<2];
void pushup(int x) { t[x]=(t[x<<1]+t[x<<1|1])%mod; }
void maketag(int x,int d) {
    (t[x]*=d)%=mod;
    (tag[x]*=d)%=mod;
}
void pushdown(int x) {
    if(tag[x]!=1) {
        maketag(x<<1,tag[x]);
        maketag(x<<1|1,tag[x]);
        tag[x]=1;
    }
}
void build(int x=1,int l=1,int r=n) {
    tag[x]=1;
    if(l==r) return;
    int mid=(l+r)>>1;
    build(x<<1,l,mid);
    build(x<<1|1,mid+1,r);
}
void mdf(int p,int d,int x=1,int l=1,int r=n) {
    if(l==r) {
        t[x]=d*tag[x]%mod;
        return;
    }
    int mid=(l+r)>>1;
    pushdown(x);
    if(p<=mid) mdf(p,d,x<<1,l,mid);
    else mdf(p,d,x<<1|1,mid+1,r);
    pushup(x);
}
void upd(int L,int R,int d,int x=1,int l=1,int r=n) {
    if(L<=l&&r<=R) {
        maketag(x,d);
        return;
    }
    int mid=(l+r)>>1;
    pushdown(x);
    if(L<=mid) upd(L,R,d,x<<1,l,mid);
    if(R>mid) upd(L,R,d,x<<1|1,mid+1,r);
    pushup(x);
}
int query(int L,int R,int op,int x=1,int l=1,int r=n) {
    if(L<=l&&r<=R) {
        if(op) return t[x];
        else return tag[x];
    }
    int mid=(l+r)>>1, res=0;
    pushdown(x);
    if(L<=mid) (res+=query(L,R,op,x<<1,l,mid))%=mod;
    if(R>mid) (res+=query(L,R,op,x<<1|1,mid+1,r))%=mod;
    return res;
}
signed main() {
    n=1;
    w[1]=read(), q=read();
    rep(i,1,q) {
        op[i]=read(), node[i]=read();
        if(op[i]&1) {
            ++n;
            w[n]=read();
            p[node[i]].pb(n);
            node[i]=n;
        }
    }
    dfs(1,0);
    build();
    mdf(dfn[1],w[1]);
    rep(i,1,n) rsz[i]=1;
    rep(i,1,q) {
        int x=node[i];
        if(op[i]&1) {
            int val=(rsz[fa[x]]+1)*fp(rsz[fa[x]],mod-2)%mod;
            ++rsz[fa[x]];
            upd(dfn[fa[x]],dfn[fa[x]]+sz[fa[x]]-1,val);
            mdf(dfn[x],w[x]);
        } else {
            int ans=query(dfn[x],dfn[x]+sz[x]-1,1);
            int inv=1;
            if(x!=1) inv=query(dfn[fa[x]],dfn[fa[x]],0);
            printf("%lld\n",ans*fp(inv,mod-2)%mod);
        }
    }
    return 0;
}
```
