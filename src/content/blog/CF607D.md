---
title: CF607D Power Tree 题解
pubDate: 2023-11-16
tags:
  - 树论
  - 线段树
categories: 题解
description: 'Solution'
---

## Solution

考虑 $f(x)$ 的实际意义。

写出来就是

$$
f(x) = \sum_{y \in \text{subtree}(x)} w_y \prod_{z \in (x \rightarrow y)} sz_z
$$

容易想到把 $(x \rightarrow y)$ 这条链差分掉，由于模数是 $10^9+7$ 所以存在乘法逆元，那么

$$
f(x) = \sum_{y \in \text{subtree}(x)} w_y \frac{\prod_{z \in (1 \rightarrow y)}sz_z}{\prod_{z \in (1 \rightarrow fa_x)}sz_z}
$$

设 $pre_x = \prod_{y \in (1 \rightarrow x)} sz_y$，得到

$$
f(x) = \frac{1}{pre_{fa_x}} \sum_{y \in \text{subtree}(x)} w_y \times pre_{y}
$$

这个是容易计算的。

我们先把树建立起来，然后把点拍到 $\text{DFS}$ 序上，线段树维护子树信息。

具体的，当 $sz_x$ 改变后，$\text{subtree}(x)$ 中的点乘上 $\frac{sz_x+1}{sz_x}$。但是此时有可能有点还没有被建立起来，所以我们要额外维护 $\sum_{y \in \text{subtree}(x)} w_y \times pre_y$。对于 $pre_x$ 的更新，我们直接打标记，同时线段树的叶子节点 $dfn_x$ 的标记值就等于 $pre_x$；对于节点 $x$ 的建立，我们直接递归到叶子节点上令其权值为 $w_x$ 乘此时的 $pre$ 标记值，然后`pushup`对其求和即可。

对于询问，直接查询 $x$ 的子树和并求 $pre_{fa_x}$ 的逆元。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define uint unsigned long long
#define PII pair<int,int>
#define MP make_pair
#define fi first
#define se second
#define pb push_back
#define eb emplace_back
#define SET(a,b) memset(a,b,sizeof(a))
#define CPY(a,b) memcpy(a,b,sizeof(b))
#define rep(i,j,k) for(int i=(j);i<=(k);++i)
#define per(i,j,k) for(int i=(j);i>=(k);--i)
int read() {
    int a=0, f=1; char c=getchar();
    while(!isdigit(c)) {
        if(c=='-') f=-1;
        c=getchar();
    }
    while(isdigit(c)) a=a*10+c-'0', c=getchar();
    return a*f;
}
const int N=2e5+5, mod=1e9+7;
int n, q, w[N], rsz[N];
int num, dfn[N], sz[N], fa[N];
int node[N], op[N];
vector<int> p[N];
int fp(int a,int b) {
    int c=1;
    for(;b;a=a*a%mod,b>>=1) {
        if(b&1) c=c*a%mod;
    }
    return c;
}
void dfs(int x,int fat) {
    fa[x]=fat;
    sz[x]=1;
    dfn[x]=++num;
    for(auto y:p[x]) if(y!=fat) {
        dfs(y,x);
        sz[x]+=sz[y];
    }
}
int t[N<<2], tag[N<<2];
void pushup(int x) { t[x]=(t[x<<1]+t[x<<1|1])%mod; }
void maketag(int x,int d) {
    (t[x]*=d)%=mod;
    (tag[x]*=d)%=mod;
}
void pushdown(int x) {
    if(tag[x]!=1) {
        maketag(x<<1,tag[x]);
        maketag(x<<1|1,tag[x]);
        tag[x]=1;
    }
}
void build(int x=1,int l=1,int r=n) {
    tag[x]=1;
    if(l==r) return;
    int mid=(l+r)>>1;
    build(x<<1,l,mid);
    build(x<<1|1,mid+1,r);
}
void mdf(int p,int d,int x=1,int l=1,int r=n) {
    if(l==r) {
        t[x]=d*tag[x]%mod;
        return;
    }
    int mid=(l+r)>>1;
    pushdown(x);
    if(p<=mid) mdf(p,d,x<<1,l,mid);
    else mdf(p,d,x<<1|1,mid+1,r);
    pushup(x);
}
void upd(int L,int R,int d,int x=1,int l=1,int r=n) {
    if(L<=l&&r<=R) {
        maketag(x,d);
        return;
    }
    int mid=(l+r)>>1;
    pushdown(x);
    if(L<=mid) upd(L,R,d,x<<1,l,mid);
    if(R>mid) upd(L,R,d,x<<1|1,mid+1,r);
    pushup(x);
}
int query(int L,int R,int op,int x=1,int l=1,int r=n) {
    if(L<=l&&r<=R) {
        if(op) return t[x];
        else return tag[x];
    }
    int mid=(l+r)>>1, res=0;
    pushdown(x);
    if(L<=mid) (res+=query(L,R,op,x<<1,l,mid))%=mod;
    if(R>mid) (res+=query(L,R,op,x<<1|1,mid+1,r))%=mod;
    return res;
}
signed main() {
    n=1;
    w[1]=read(), q=read();
    rep(i,1,q) {
        op[i]=read(), node[i]=read();
        if(op[i]&1) {
            ++n;
            w[n]=read();
            p[node[i]].pb(n);
            node[i]=n;
        }
    }
    dfs(1,0);
    build();
    mdf(dfn[1],w[1]);
    rep(i,1,n) rsz[i]=1;
    rep(i,1,q) {
        int x=node[i];
        if(op[i]&1) {
            int val=(rsz[fa[x]]+1)*fp(rsz[fa[x]],mod-2)%mod;
            ++rsz[fa[x]];
            upd(dfn[fa[x]],dfn[fa[x]]+sz[fa[x]]-1,val);
            mdf(dfn[x],w[x]);
        } else {
            int ans=query(dfn[x],dfn[x]+sz[x]-1,1);
            int inv=1;
            if(x!=1) inv=query(dfn[fa[x]],dfn[fa[x]],0);
            printf("%lld\n",ans*fp(inv,mod-2)%mod);
        }
    }
    return 0;
}
```


