---
title: CF1253F Cheap Robot 题解
pubDate: 2023-11-16
tags:
  - 图论
  - 最短路
  - 并查集
categories: 题解
description: 'Solution'
---

## Solution

因为保证 $a,b$ 都是关键点，并且不关心从 $a$ 到 $b$ 是怎么走的，所以我们的最优策略就是每走到一个节点，就去离它最近的关键点充电，然后再走回来，这样相对于其他策略，走到同一个点的电量可能更多而不可能更少。

我们处理出 $d_x$ 表示 $x$ 到最近的关键点的距离，设当前电量上限为 $C$，那么 $(x,y,z)$ 这条边可以通过，当且仅当 $C - d_x - z \ge d_y$，也就是 $C \ge d_x + d_y +z$。建立超级源点，向所有关键点连权值为 $0$ 的边，然后跑单源最短路，到 $x$ 的最短距离就是 $d_x$。

因此电量 $c$ 能从 $a$ 能走到 $b$，当且仅当加入所有满足 $c \ge d_x+d_y+z$ 的边后，$a,b$ 连通。

在线做比较繁琐，考虑离线处理。

我们按照权值从小到大枚举每一条边 $(x,y,z)$，令 $c=z$ 并在图中加入这条边，用并查集维护连通块。如果存在一个询问 $(a,b)$ 因此而联通，那么 $z$ 就是其答案。

我们把询问 $(a,b)$ 挂到 $a$ 和 $b$ 上，合并两个连通块时按秩合并，回答较小集合内的询问即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define uint unsigned long long
#define PII pair<int,int>
#define MP make_pair
#define fi first
#define se second
#define pb push_back
#define eb emplace_back
#define SET(a,b) memset(a,b,sizeof(a))
#define CPY(a,b) memcpy(a,b,sizeof(b))
#define rep(i,j,k) for(int i=(j);i<=(k);++i)
#define per(i,j,k) for(int i=(j);i>=(k);--i)
int read() {
    int a=0, f=1; char c=getchar();
    while(!isdigit(c)) {
        if(c=='-') f=-1;
        c=getchar();
    }
    while(isdigit(c)) a=a*10+c-'0', c=getchar();
    return a*f;
}
const int N=1e5+5, M=3e5+5, inf=0x0f0f0f0f0f0f0f0f;
int n, m, k, Q, d[N], ans[M];
bool v[N];
vector<PII > p[N];
struct edge {
    int x, y, z;
    bool operator<(const edge& b) const {
        return z<b.z;
    }
} e[M];
int fa[N], sz[N];
vector<edge> vec[N];
int get(int x) {
    if(x==fa[x]) return x;
    return fa[x]=get(fa[x]);
}
void dijkstra() {
    priority_queue<PII > q;
    rep(i,1,n) d[i]=inf;
    d[0]=0;
    q.push({0,0});
    while(q.size()) {
        int x=q.top().se; q.pop();
        if(v[x]) continue;
        v[x]=1;
        for(auto t:p[x]) {
            int y=t.fi, z=t.se;
            if(d[y]>d[x]+z) {
                d[y]=d[x]+z;
                q.push({-d[y],y});
            }
        }
    }
}
signed main() {
    n=read(), m=read(), k=read(), Q=read();
    rep(i,1,m) {
        e[i].x=read(), e[i].y=read(), e[i].z=read();
        p[e[i].x].pb({e[i].y,e[i].z}), p[e[i].y].pb({e[i].x,e[i].z});
    }
    rep(i,1,k) p[0].pb({i,0}), p[i].pb({0,0});
    dijkstra();
    rep(i,1,m) e[i].z+=d[e[i].x]+d[e[i].y];
    sort(e+1,e+m+1);
    rep(i,1,n) fa[i]=i, sz[i]=1;
    rep(i,1,Q) {
        int x=read(), y=read();
        edge t;
        t.x=x, t.y=y, t.z=i;
        vec[x].pb(t), vec[y].pb(t);
    }
    rep(i,1,m) {
        int x=e[i].x, y=e[i].y, z=e[i].z;
        x=get(x), y=get(y);
        if(x==y) continue;
        if(sz[x]<sz[y]) swap(x,y);
        sz[x]+=sz[y];
        fa[y]=x;
        for(auto t:vec[y]) {
            if(get(t.x)==get(t.y)) {
                if(!ans[t.z]) ans[t.z]=z;
            } else vec[x].pb(t);
        }
    }
    rep(i,1,Q) printf("%lld\n",ans[i]);
    return 0;
}

```
