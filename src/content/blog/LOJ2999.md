---
title: LOJ#2999 「JOISC 2015 Day2」 Keys 题解
pubDate: 2023-09-15
tags:
  - DP
  - 扫描线
categories:
  - 题解
description: 'Solution'
---

## Solution

发现很难直接从社员上下手。

由于产生贡献的不是社员，而是夹在社员离开和回来的事件中的时间，所以我们先不考虑钥匙的分配，尝试统计事件的贡献。

把所有事件按照时间排序，对于事件 $i$ 与 $i+1$ 进行分类讨论。下面称 $i$ 事件对应的人为 $x$，$i+1$ 事件对应的人为 $y$。

1. $i$ 出，$i+1$ 出。此时有贡献当且仅当 $x$ 有钥匙。

2. $i$ 出，$i+1$ 进。此时有贡献当且仅当 $x$ 与 $y$ 都有钥匙。

3. $i$ 进，$i+1$ 出。此时无论何种情况都有贡献。

4. $i$ 进，$i+1$ 进。此时有贡献当且仅当 $y$ 有钥匙。

如何最大化贡献呢？

第 3 种贡献可以单独拿出来。

对于第 1 种和第 4 种贡献，我们把这个值记录到点上，那么只有当这个点被分配到钥匙时才有贡献。

对于第 2 种贡献，我们尝试连边 $(x \rightarrow y)$，权值为两个事件的贡献，这样就会建出一张有向图。问题转化为在图上选出 $k$ 个关键点，一个点被选择就会贡献出它的点权，一条边的两个端点同时被选择就会贡献出其边权。

更进一步地，这张图是由若干条链构成的，所以我们从每条链的起点开始 $\text{DFS}$，跑出 $\text{DFS}$ 序后排到序列上直接 DP 就行了。

设 $f(i,j,0/1)$ 为考虑了 $\text{DFS}$ 序中前 $i$ 个点，选择了 $j$ 个，当前节点有没有选的最大收益。转移是平凡的。

时间复杂度 $O(n^2)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define uint unsigned long long
#define PII pair<int,int>
#define MP make_pair
#define fi first
#define se second
#define pb push_back
#define eb emplace_back
#define SET(a,b) memset(a,b,sizeof(a))
#define CPY(a,b) memcpy(a,b,sizeof(b))
#define rep(i,j,k) for(int i=(j);i<=(k);++i)
#define per(i,j,k) for(int i=(j);i>=(k);--i)
int read() {
    int a=0, f=1; char c=getchar();
    while(!isdigit(c)) {
        if(c=='-') f=-1;
        c=getchar();
    }
    while(isdigit(c)) a=a*10+c-'0', c=getchar();
    return a*f;
}
const int N=2e3+5, inf=0x0f0f0f0f0f0f0f0f;
int n, m, k, cnt, v[N], in[N];
int num, idf[N], w[N];
int ans, f[N][N][2];
struct node {
    int x, id, type;
    node() {}
    node(int _x,int _id,int _ty) { x=_x, id=_id, type=_ty; }
    bool operator<(const node& b) const { return x<b.x; }
} a[N<<1];
vector<PII > p[N];
void add(int x,int y,int z) {
    p[x].pb({y,z});
}
void dfs(int x,int pre) {
    idf[++num]=x, w[num]=pre;
    for(auto t:p[x]) dfs(t.fi,t.se);
}
signed main() {
    n=read(), m=read(), k=read();
    rep(i,1,n) {
        int s=read(), t=read();
        a[++cnt]=node(s,i,0);
        a[++cnt]=node(t,i,1);
    }
    sort(a+1,a+cnt+1);
    rep(i,1,cnt-1) {
        int d=a[i+1].x-a[i].x;
        int x=a[i].id, y=a[i+1].id;
        if(x==y) { v[x]+=d; continue; }
        // 同一个人进出，x有钥匙时有贡献
        if(!a[i].type) {
            // i出
            if(!a[i+1].type) v[x]+=d;
            //i+1出，x有钥匙时有贡献
            else add(x,y,d), ++in[y];
            // i+1进，二者都有钥匙时有贡献
        } else {
            // i进
            if(!a[i+1].type) ans+=d;
            // i+1出，无论如何一定有贡献
            else v[y]+=d;
            // i+1进，y有钥匙时有贡献
        }
    }
    // 把链串起来拍到序列上
    rep(i,1,n) if(!in[i]) dfs(i,0);

    ans+=a[1].x+(m-a[cnt].x);
    SET(f,-0x0f);
    f[0][0][0]=0;
    rep(i,1,n) for(int j=0;j<=min(k,i);++j) {
        f[i][j][0]=max(f[i-1][j][0],f[i-1][j][1]);
        if(j) f[i][j][1]=max(f[i-1][j-1][0],f[i-1][j-1][1]+w[i])+v[idf[i]];
    }
    printf("%lld\n",max(f[n][k][0],f[n][k][1])+ans);
    return 0;
}
```




