---
title: CF708C Centroids 题解
pubDate: 2023-10-23
tags:
  - 树的重心
  - DP
  - 树形DP
  - 换根法
categories:
  - 题解
description: 'Solution'
---

## Solution

考虑一个点 $x$ 何时能通过改造成为重心，为了方便，钦定 $x$ 为树根。

通过操作干掉的子树一定会接到 $x$ 上，否则不优。

1. $\max_{y \in son(x)} \{ sz_y\} \le \lfloor \frac{n}{2} \rfloor$。
2. 存在 $y \in son(x)$ 满足 $sz_y > \lfloor \frac{n}{2} \rfloor$，但是 $y$ 的子树中存在一棵子树 $z$，满足 $sz_z \le \lfloor \frac{n}{2} \rfloor$ 并且 $sz_y - sz_z \le \lfloor \frac{n}{2} \rfloor$。

第一种情况是平凡的，预处理重儿子即可，不再赘述。

对于第二种情况，不难发现取 $z$ 为 $sz$ 最大的 $i$，满足 $sz_i \le \lfloor \frac{n}{2} \rfloor$ 最优。通过树形 DP 不难求出。

对于每个节点的情况，考虑用换根 DP 统计答案。唯一的困难就是，如果从 $x$ 进入了 $z$ 所在的子树，那么就需要有一个次大的 $z'$ 来代替关于 $x$ 的 $z$。

设 $f(x,0)$ 为满足条件的 $sz$ 最大的 $z$，$f(x,1)$ 是次大，同时记录 $f(x,0)$ 的来源 $id_x$ 即可换根。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define uint unsigned long long
#define PII pair<int,int>
#define MP make_pair
#define fi first
#define se second
#define pb push_back
#define eb emplace_back
#define SET(a,b) memset(a,b,sizeof(a))
#define CPY(a,b) memcpy(a,b,sizeof(b))
#define rep(i,j,k) for(int i=(j);i<=(k);++i)
#define per(i,j,k) for(int i=(j);i>=(k);--i)
int read() {
    int a=0, f=1; char c=getchar();
    while(!isdigit(c)) {
        if(c=='-') f=-1;
        c=getchar();
    }
    while(isdigit(c)) a=a*10+c-'0', c=getchar();
    return a*f;
}
const int N=4e5+5;
int n, sz[N], son[N], f[N][2], id[N];
int ans[N];
vector<int> p[N];
void dfs(int x,int fa) {
    sz[x]=1;
    for(auto y:p[x]) if(y!=fa) {
        dfs(y,x);
        sz[x]+=sz[y];
        if(sz[y]>sz[son[x]]) son[x]=y;
        int t=0;
        if(sz[y]>n/2) t=f[y][0]; else t=sz[y];
        if(t>f[x][0]) f[x][1]=f[x][0], f[x][0]=t, id[x]=y;
        else if(t>f[x][1]) f[x][1]=t;
    }
    // printf("f[%lld][0]=%lld f[%lld][1]=%lld\n",x,f[x][0],x,f[x][1]);
}
void dfs2(int x,int fa) {
    if(sz[son[x]]<=n/2) ans[x]=1;
    else if(f[son[x]][0]>0&&sz[son[x]]-f[son[x]][0]<=n/2) ans[x]=1;
    // if(x==1||x==3) {
    //     printf("f[%lld][0]=%lld f[%lld][1]=%lld\n",x,f[x][0],x,f[x][1]);
    //     printf("son[%lld]=%lld\n",x,son[x]);
    // }
    int szx=sz[x], fx0=f[x][0];
    for(auto y:p[x]) if(y!=fa) {

        int szy=sz[y], sony=son[y], fy0=f[y][0], fy1=f[y][1], idy=id[y];

        sz[x]=n-sz[y];
        sz[y]=n;
        if(sz[x]>sz[son[y]]) son[y]=x;
        if(y!=id[x]) {
            int t=0;
            if(sz[x]>n/2) t=f[x][0]; else t=sz[x];
            if(t>f[y][0]) f[y][1]=f[y][0], f[y][0]=t, id[y]=x;
            else if(t>f[y][1]) f[y][1]=t;
        } else {
            int t=0;
            if(sz[x]>n/2) t=f[x][1]; else t=sz[x];
            if(t>f[y][0]) f[y][1]=f[y][0], f[y][0]=t, id[y]=x;
            else if(t>f[y][1]) f[y][1]=t;
            f[x][0]=f[x][1];
        }
        dfs2(y,x);

        sz[x]=szx, f[x][0]=fx0;
        sz[y]=szy, son[y]=sony, f[y][0]=fy0, f[y][1]=fy1, id[y]=idy;
    }
}
signed main() {
    n=read();
    rep(i,2,n) {
        int x=read(), y=read();
        p[x].pb(y), p[y].pb(x);
    }
    dfs(1,0);
    dfs2(1,0);
    rep(i,1,n) printf("%lld ",ans[i]);
    puts("");
    return 0;
}
```
