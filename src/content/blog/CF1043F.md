---
title: CF1043F Make It One 题解
pubDate: 2023-11-08
tags:
  - 数论
  - DP
  - 组合数学
  - 容斥原理
  - 莫比乌斯反演
categories: 题解
description: 'Solution'
---

## Solution

$\textbf{Lemma}$

> 如果有解，那么答案不大于 $7$。

$\textbf{Proof}$

> 由于 $a_i \in [1,3 \times 10^5]$，所以 $\omega(a_i) \le 6$。
> 
> 严格证明上界为 $7$ 略显繁琐，下面给出一种方案。
> 
> 由于 $2 \times 3 \times 5 \times 7 \times 11 \times 13 \times 17 = 510510$，去掉任意一个质因子后都在范围内，所以我们选出这 $7$ 个数，它们的 $\gcd$ 显然为 $1$，且集合大小为 $7$。
> 
> 下面证明答案不会达到 $8$。
> 
> 反证法。假设某个序列的答案为 $8$，那么从中任选 $7$ 个数都存在一个质因子，满足它在每一个数中都出现过。
> 
> 如果此时存在两种选择方式使得满足上述性质的质因子集合是另一种方案的子集，那么这 $8$ 个数的 $\gcd$ 就不为 $1$，从而不存在这种情况。
> 
> 考虑钦定一个数必须被选择的方案数为 $\binom{7}{6}=7$，所以这个数就有至少 $7$ 个不同的质因子，与 $\omega(a_i) \le 6$ 矛盾。
> 
> 证毕。

然后我们就可以枚举答案了，问题转化为能够选出 $k$ 个数使得他们的 $\gcd=1$。

设 $g(x)$ 为选出的数存在公约数为 $x$ 的方案数，$f(x)$ 为选出的数的 $\gcd=x$ 的方案数，有

$$
f(x) = g(x) - \sum_{x \mid y, y \neq x} f(y)
$$

设 $c_x = \sum_{x \mid y} [y \in \{a\}]$，有

$$
g(x) = \binom{c_x}{n}
$$

最终求 $f(1)$ 即可。

不过我们也能看出来

$$
g(x) = \sum_{x \mid y} f(y)
$$

所以

$$
f(x) = \sum_{x \mid y} \mu \Big(\frac{y}{x} \Big) g(y)
$$



对于 $f(1)$，筛了 $\mu$ 之后乱做。

只写了第一种做法的代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define uint unsigned long long
#define PII pair<int,int>
#define MP make_pair
#define fi first
#define se second
#define pb push_back
#define eb emplace_back
#define SET(a,b) memset(a,b,sizeof(a))
#define CPY(a,b) memcpy(a,b,sizeof(b))
#define rep(i,j,k) for(int i=(j);i<=(k);++i)
#define per(i,j,k) for(int i=(j);i>=(k);--i)
int read() {
    int a=0, f=1; char c=getchar();
    while(!isdigit(c)) {
        if(c=='-') f=-1;
        c=getchar();
    }
    while(isdigit(c)) a=a*10+c-'0', c=getchar();
    return a*f;
}
const int N=3e5+5, mod=1e9+7;
int n, lim, c[N], f[N];
int fac[N], inv[N];
int fp(int a,int b) {
    int c=1;
    for(;b;a=a*a%mod,b>>=1) if(b&1) c=c*a%mod;
    return c;
}
int binom(int n,int m) {
    if(n<m||n<0||m<0) return 0;
    return fac[n]*inv[m]%mod*inv[n-m]%mod;
}
void prework() {
    fac[0]=inv[0]=1;
    rep(i,1,n) fac[i]=fac[i-1]*i%mod;
    inv[n]=fp(fac[n],mod-2);
    per(i,n-1,1) inv[i]=inv[i+1]*(i+1)%mod; 
}
int MyGO(int x) {
    for(int i=lim;i;--i) {
        f[i]=binom(c[i],x);
        for(int j=2;i*j<=lim;++j) (f[i]-=f[i*j]-mod)%=mod;
    }
    return f[1];
}
signed main() {
    n=read();
    rep(i,1,n) {
        int x=read();
        ++c[x];
        lim=max(lim,x);
    }
    rep(i,1,lim) for(int j=2*i;j<=lim;j+=i) c[i]+=c[j]; 
    prework();
    for(int i=1;i<=min(n,7ll);++i) if(MyGO(i)) {
        printf("%lld\n",i);
        return 0;
    }
    puts("-1");
    return 0;
}
```


