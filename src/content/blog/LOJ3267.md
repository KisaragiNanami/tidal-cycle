---
title: LOJ#3267 Help Yourself 题解
pubDate: 2023-09-07
tags:
  - DP
  - 线段树
categories: 题解
description: 'Solution'
---

## Help Yourself Gold

考虑每条线段的贡献。

把所有线段按左端点排序，设 $f(i)$ 为前 $i$ 条线段所有子集的贡献和。

- 不选 $i$，贡献是 $f(i-1)$。
- 选 $i$。设有 $cnt$ 条线段 $j$ 满足 $r_j < l_i$，那么当选出的线段子集是这些线段的子集时，贡献都会增加 $1$，否则不变。因此贡献是 $f(i-1)+2^{cnt}$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define uint unsigned long long
#define PII pair<int,int>
#define MP make_pair
#define fi first
#define se second
#define pb push_back
#define eb emplace_back
#define SET(a,b) memset(a,b,sizeof(a))
#define CPY(a,b) memcpy(a,b,sizeof(b))
#define rep(i,j,k) for(int i=(j);i<=(k);++i)
#define per(i,j,k) for(int i=(j);i>=(k);--i)
int read() {
    int a=0, f=1; char c=getchar();
    while(!isdigit(c)) {
        if(c=='-') f=-1;
        c=getchar();
    }
    while(isdigit(c)) a=a*10+c-'0', c=getchar();
    return a*f;
}
const int N=1e6+5, mod=1e9+7;
int n, pw[N], f[2*N], cnt[2*N];
bool cmp(PII a,PII b) { return a.se<b.se; }
PII a[N];
signed main() {
    n=read();
    pw[0]=1;
    rep(i,1,n) a[i].fi=read(), a[i].se=read(), pw[i]=pw[i-1]*2%mod, cnt[a[i].se]=1;
    sort(a+1,a+n+1);
    for(int i=1;i<=2*n;++i) cnt[i]+=cnt[i-1];
    f[0]=0;
    for(int i=1;i<=n;++i) {
        f[i]=(2*f[i-1]%mod+pw[cnt[a[i].fi-1]])%mod;
    }
    printf("%lld\n",f[n]);
    return 0;
}
```

## Help Yourself Platinum

把所有线段按照左端点排序。

设 $f_{\delta}(i,r)$ 表示考虑了前 $i$ 条线段，最右边的端点在 $r$，所有线段子集的**并**的连通块数 $\delta$ 次方和。

形式化地，有

$$
f_{\delta}(i,r) = \sum_{S \subseteq U, \text{endpos}(S)=r} \text{cnt}(S)^{\delta}
$$



其中 $\text{cnt}(S)$ 为线段**并** $S$ 的连通块数量。

定义变换 $\mathcal{T}\Big(f_{\delta}(i,r)\Big)$ 表示对状态 $f_{\delta}(i,r)$ 中所有 $\text{cnt}(S)$ 进行 $+1$ 操作后得到的值。

对新加入的线段端点进行讨论，可得

$$
f_{\delta}(i,r_i) = \sum_{j=0}^{l_i-1} \mathcal{T}\Big(f_{\delta}(i-1,j)\Big) + \sum_{j=l_i}^{r_i} f_{\delta}(i-1,j)
$$



然后对于 $j > r_i$，有

$$
f_{\delta}(i-1,j) \rightarrow f_{\delta}(i,j)
$$



然后我们考虑如何实现 $\mathcal{T}$。

$$
\mathcal{T}\Big(f_{\delta}(i,j)\Big) = \sum_{S \subseteq U} \Big(\text{cnt}(S)+1\Big)^{\delta} = \sum_{S \subseteq U} \sum_{k=0}^{\delta} \binom{\delta}{k} \text{cnt}(S)^{k} = \sum_{k=0}^{\delta} \binom{\delta}{k} f_{k}(i,j)
$$



可以 $O(K)$ 求出。

所以得到了一个 $O(n^2 K^2)$ 的做法，可以得到 $50 \text{pts}$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define uint unsigned long long
#define PII pair<int,int>
#define MP make_pair
#define fi first
#define se second
#define pb push_back
#define eb emplace_back
#define SET(a,b) memset(a,b,sizeof(a))
#define CPY(a,b) memcpy(a,b,sizeof(b))
#define rep(i,j,k) for(int i=(j);i<=(k);++i)
#define per(i,j,k) for(int i=(j);i>=(k);--i)
int read() {
    int a=0, f=1; char c=getchar();
    while(!isdigit(c)) {
        if(c=='-') f=-1;
        c=getchar();
    }
    while(isdigit(c)) a=a*10+c-'0', c=getchar();
    return a*f;
}
const int N=1005, mod=1e9+7;
int n, K, pre[N], f[12][N][2*N];
int c[20][20];
PII a[N];
int T(int k,int i,int j) {
    int res=0;
    rep(t,0,k) {
        (res+=c[k][t]*f[t][i][j]%mod)%=mod;
    }
    return res;
}
void calc(int k) {
    f[k][1][a[1].se]=1;
    f[k][1][0]=(k==0? 1:0);
    rep(i,2,n) {
        int l=a[i].fi, r=a[i].se;
        rep(j,0,pre[i]) f[k][i][j]+=f[k][i-1][j];
        // f[k][i][r]=f[k][i-1][r];
        rep(j,0,l-1) {
            (f[k][i][r]+=T(k,i-1,j))%=mod;
        }
        rep(j,l,r) {
            (f[k][i][r]+=f[k][i-1][j])%=mod;
        }
        rep(j,r+1,pre[i])  {
            (f[k][i][j]+=f[k][i-1][j])%=mod;
        }
    }
}
void prework() {
    rep(i,1,n) pre[i]=max(pre[i-1],a[i].se);
    c[0][0]=1;
    rep(i,1,10) {
        c[i][0]=c[i][i]=1;
        rep(j,1,i-1) c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod;
    }
}
signed main() {
    n=read(), K=read();
    rep(i,1,n) a[i].fi=read(), a[i].se=read();
    sort(a+1,a+n+1);
    prework();
    for(int k=0;k<=K;++k) calc(k);
    int ans=0;
    rep(i,1,pre[n]) (ans+=f[K][n][i])%=mod;
    printf("%lld\n",ans);
    return 0;
}
```

考虑优化。

观察 $\mathcal{T}$，可以发现

$$
\sum_{j=0}^{l_i-1} \mathcal{T}\Big(f_{\delta}(i-1,j)\Big) = \mathcal{T}\Big( \sum_{j=0}^{l_i-1} f_{\delta}(i-1,j) \Big)
$$



组合意义比较 $\text{Trivial}$。

套路性的把 $j$ 这一维拍到线段树上，每个线段树节点维护 $j$ 点上 $\delta \in [0,K]$ 时对应的 $f$ 值。

每加入一条线段 $[l_i,r_i]$，做三种操作：

1. 对 $r_i$ 单点加 $\mathcal{T}\Big( \sum_{j=0}^{l_i-1} f_{\delta}(i-1,j) \Big)$。
2. 对 $r_i$ 单点加 $\sum_{j=l_i}^{r_i} f_{\delta}(i-1,j)$。
3. 对 $[r_i+1,2n]$ 区间乘 $2$。

注意查询操作需要在修改操作之前。

时间复杂度 $O(n K^2 + n \log_2 nK)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define uint unsigned long long
#define PII pair<int,int>
#define MP make_pair
#define fi first
#define se second
#define pb push_back
#define eb emplace_back
#define SET(a,b) memset(a,b,sizeof(a))
#define CPY(a,b) memcpy(a,b,sizeof(b))
#define rep(i,j,k) for(int i=(j);i<=(k);++i)
#define per(i,j,k) for(int i=(j);i>=(k);--i)
int read() {
    int a=0, f=1; char c=getchar();
    while(!isdigit(c)) {
        if(c=='-') f=-1;
        c=getchar();
    }
    while(isdigit(c)) a=a*10+c-'0', c=getchar();
    return a*f;
}
const int N=1e5+5, mod=1e9+7;
int n, m, K, c[20][20];
PII a[N];
struct node {
    int s[11];
    void init() { SET(s,0); }
    node() { init(); }
    node operator+(const node& o) {
        node r=*this;
        rep(i,0,K) r.s[i]=(s[i]+o.s[i])%mod;
        return r;
    }
    void operator*=(const int& a) {
        rep(i,0,K) (s[i]*=a)%=mod;
    }
};
node t[N<<3];
int tag[N<<3];
node T(node a) {
    node res=node();
    for(int i=0;i<=K;++i) for(int j=0;j<=i;++j) {
        (res.s[i]+=c[i][j]*a.s[j]%mod)%=mod;
    }
    return res;
}
void pushup(int x) { t[x]=t[x<<1]+t[x<<1|1]; }
void maketag(int x,int d) {
    t[x]*=d;
    (tag[x]*=d)%=mod;
}
void pushdown(int x) {
    if(tag[x]>1) {
        maketag(x<<1,tag[x]);
        maketag(x<<1|1,tag[x]);
        tag[x]=1;
    }
}
void build(int x=1,int l=0,int r=m) {
    tag[x]=1;
    if(l==r) {
        if(l==0) t[x].s[0]=1;
        return;
    }
    int mid=(l+r)>>1;
    build(x<<1,l,mid);
    build(x<<1|1,mid+1,r);
    pushup(x);
}
node query(int L,int R,int x=1,int l=0,int r=m) {
    if(L<=l&&r<=R) return t[x];
    pushdown(x);
    int mid=(l+r)>>1;
    node res=node();
    if(L<=mid) res=res+query(L,R,x<<1,l,mid);
    if(R>mid) res=res+query(L,R,x<<1|1,mid+1,r);
    return res;
}
void mdf(int p,node& d,int x=1,int l=0,int r=m) {
    if(l==r) {
        t[x]=t[x]+d;
        return;
    }
    pushdown(x);
    int mid=(l+r)>>1;
    if(p<=mid) mdf(p,d,x<<1,l,mid);
    else mdf(p,d,x<<1|1,mid+1,r);
    pushup(x);
}
void upd(int L,int R,int d,int x=1,int l=0,int r=m) {
    if(L<=l&&r<=R) {
        maketag(x,d);
        return;
    }
    pushdown(x);
    int mid=(l+r)>>1;
    if(L<=mid) upd(L,R,d,x<<1,l,mid);
    if(R>mid) upd(L,R,d,x<<1|1,mid+1,r);
    pushup(x);
}
void prework() {
    c[0][0]=1;
    rep(i,1,10) {
        c[i][0]=c[i][i]=1;
        rep(j,1,i-1) c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod;
    }
}
signed main() {
    n=read(), K=read();
    m=n<<1;
    rep(i,1,n) a[i].fi=read(), a[i].se=read();
    sort(a+1,a+n+1);
    prework();
    build();
    rep(i,1,n) {
        int l=a[i].fi, r=a[i].se;
        node d=T(query(0,l-1))+query(l,r);
        mdf(r,d);
        if(r+1<=m) upd(r+1,m,2);
    }
    printf("%lld\n",t[1].s[K]);
    return 0;
}
```
