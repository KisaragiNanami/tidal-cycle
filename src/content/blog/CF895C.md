---
title: CF895C Square Subsets 题解
pubDate: 2023-10-23
tags:
  - DP
  - 状态压缩
categories:
  - 题解

---

## Solution

注意到值域很小，然后值域范围内的质数只有 $19$ 个。

把相同的数合并成内部有标号的等价类，设 $f(i,S)$ 为考虑了 $1 \sim i$ 的数，选出的数的乘积中，每个质因子出现次数奇偶性为 $S$ 的方案数。

枚举选奇数个还是偶数个，随便转移。

貌似要滚动一下。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define uint unsigned long long
#define PII pair<int,int>
#define MP make_pair
#define fi first
#define se second
#define pb push_back
#define eb emplace_back
#define SET(a,b) memset(a,b,sizeof(a))
#define CPY(a,b) memcpy(a,b,sizeof(b))
#define rep(i,j,k) for(int i=(j);i<=(k);++i)
#define per(i,j,k) for(int i=(j);i>=(k);--i)
int read() {
    int a=0, f=1; char c=getchar();
    while(!isdigit(c)) {
        if(c=='-') f=-1;
        c=getchar();
    }
    while(isdigit(c)) a=a*10+c-'0', c=getchar();
    return a*f;
}
const int N=1e5+5, mod=1e9+7;
const int pr[]={2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67};
int n, U, lim, c[80], pw[N], p[(1<<19)+5], f[2][(1<<19)+5];
int trans(int x) {
    int res=0;
    for(int i=0;i<19;++i) if(x%pr[i]==0) {
        int e=0;
        while(x%pr[i]==0) x/=pr[i], e^=1;
        if(e) res|=(1<<i);
    }
    return res;
}
signed main() {
    n=read();
    rep(i,1,n) {
        int x=read();
        ++c[x];
        lim=max(lim,c[x]);
        if(c[x]==1) {
            p[x]=trans(x);
            // printf("p[%lld][0]=%lld\n",x,p[x]);
        }
    }
    pw[0]=1;
    rep(i,1,lim) pw[i]=pw[i-1]*2%mod;
    U=(1<<19)-1;
    f[0][0]=1;
    for(int i=1;i<=70;++i) {
        SET(f[i&1],0);
        rep(S,0,U) {
            if(c[i]==0) (f[i&1][S]=f[(i-1)&1][S])%=mod;
            if(c[i]>0) (f[i&1][S^p[i]]+=f[(i-1)&1][S]*pw[c[i]-1]%mod)%=mod;
            if(c[i]>0) (f[i&1][S]+=f[(i-1)&1][S]*pw[c[i]-1]%mod)%=mod;
        }
    }
    printf("%lld\n",(f[0][0]-1+mod)%mod);
    // 减掉一个都不选的方案
    return 0;
}
```
