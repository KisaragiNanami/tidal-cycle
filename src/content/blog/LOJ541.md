---
title: LOJ#541「LibreOJ NOIP Round」七曜圣贤 题解
pubDate: 2023-09-15
tags:
  - 数据结构
  - 单调队列
categories:
  - 题解
description: 'Solution'
---

## Solution

先考虑暴力怎么打。

### 30pts

用个队列模拟一下捡回来，用数组标记哪些在车上，然后暴力找答案就行了。

### 特殊性质

只存在购买的操作，那么答案单调不降，直接套用上面的做法，开大空间就行了。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define uint unsigned int
#define PII pair<int,int>
#define MP make_pair
#define fi first
#define se second
#define pb push_back
#define eb emplace_back
#define SET(a,b) memset(a,b,sizeof(a))
#define CPY(a,b) memcpy(a,b,sizeof(b))
#define rep(i,j,k) for(int i=(j);i<=(k);++i)
#define per(i,j,k) for(int i=(j);i>=(k);--i)
int read() {
    int a=0, f=1; char c=getchar();
    while(!isdigit(c)) {
        if(c=='-') f=-1;
        c=getchar();
    }
    while(isdigit(c)) a=a*10+c-'0', c=getchar();
    return a*f;
}
namespace IO{
    int c;
    unsigned int seed;
    unsigned int randnum(){
        seed^=seed<<13;
        seed^=seed>>17;
        seed^=seed<<5;
        return seed;
    }
    inline void init_case(int &m,int &a,int &b,int &d,int p[]){
        m=read();
        scanf("%u",&seed);
        a=read(), b=read(), c=read(), d=read();
        for(int i=1;i<=m;i++){
            if(randnum()%c==0) p[i]=-1;
            else p[i]=randnum()%b;
        }
    }

    inline void update_ans(unsigned int &ans_sum,unsigned int cur_ans,int no){
        const static unsigned int mod=998244353;
        ans_sum^=(long long)no*(no+7)%mod*cur_ans%mod;
    }
}
using IO::init_case;
using IO::update_ans;
const int N=2e6+5, mod=998244353;
int T, m, a, b, d, p[N];
int s[N], v[N];
void solve() {
    uint ans=0u;
    init_case(m,a,b,d,p);
    int lim=max(a,b);
    rep(i,0,lim+2) s[i]=v[i]=0;
    queue<int> q;
    rep(i,0,a) s[i]=1;
    rep(i,1,m) {
        if(p[i]==-1) {
            if(d) continue;
            if(q.empty()) continue;
            int x=q.front(); q.pop();
            s[x]=1;
        } else if(p[i]>a&&!v[p[i]]) {
            s[p[i]]=1, v[p[i]]=1;
        } else if(s[p[i]]) {
            if(d) continue;
            s[p[i]]=0;
            q.push(p[i]);
        } else {
            if(q.empty()) continue;
            int x=q.front(); q.pop();
            s[x]=1;
        }
        uint res=0;
        while(s[res]>0) ++res;
        update_ans(ans,res,i);
    }
    printf("%u\n",ans);
}
signed main() {
    T=read();
    while(T--) solve();
    return 0;
}
```

### 70pts

这个暴力做法慢在枚举第一个 $0$ 的位置。

有没有什么数据结构支持单调修改，查询 0/1 序列左边第一个 $0$ 的位置呢？

线段树上全局二分即可。

结合特殊性质能拿到 $70 \text{pts}$。

代码写得比较难看，由于没啥细节这里就只放线段树了。



```cpp
int n, t[N<<2];
void pushup(int x) { t[x]=t[x<<1]&&t[x<<1|1]; }
void build(int x=1,int l=0,int r=n) {
    // 好吧细节只有一个，那就是线段树的右端点。
    // 这里取了 n=max(a,b)+1
    t[x]=0;
    if(l==r) { t[x]=(l<=a); return; }
    int mid=(l+r)>>1;
    build(x<<1,l,mid);
    build(x<<1|1,mid+1,r);
    pushup(x);
}
void upd(int p,int d,int x=1,int l=0,int r=n) {
    if(l==r) { t[x]=d; return; }
    int mid=(l+r)>>1;
    if(p<=mid) upd(p,d,x<<1,l,mid);
    else upd(p,d,x<<1|1,mid+1,r);
    pushup(x);
}
int query(int x=1,int l=0,int r=n) {
    if(l==r) return l;
    int mid=(l+r)>>1;
    if(!t[x<<1]) return query(x<<1,l,mid);
    else if(!t[x<<1|1]) return query(x<<1|1,mid+1,r);
    else return -1;
}
```

### 100pts

虽然我们什么性质都没有发现，但已经拿到 $70 \text{pts}$ 了。

终究是老题啊。

先明确答案的本质：集合 $\operatorname{mex}$。

我们把事件分成两部分：第一种就是买红茶，第二种就是红茶飞出去。

前者是对答案的贡献，后者是对答案的限制。换句话说，任何时刻的答案都能被表示为 $\min(pos,out)$，其中 $pos$ 是编号最小的还没有拥有过的红茶，$out$ 是飞出去的编号最小的红茶。

如果暴力上数据结构，那么需要支持快速查询最小值，快速加入删除某个元素。堆、平衡树都可以，但是带 $\log$ 无法通过。

$pos$ 是容易计算的，关键在于 $out$ 很难维护。

不妨设飞出去的红茶集合为 $S$。

考虑这样一个性质：当 $p_i$ 加入 $S$ 后，对于所有 $p_i > p_i,p_j \in S$，它们都是冗余元素。因为直到它们被捡回来，都不可能成为 $out$。

这是典型的二位偏序最优化问题，直接上单调队列即可。

时间复杂度 $O(m)$，可以通过。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define uint unsigned int
#define PII pair<int,int>
#define MP make_pair
#define fi first
#define se second
#define pb push_back
#define eb emplace_back
#define SET(a,b) memset(a,b,sizeof(a))
#define CPY(a,b) memcpy(a,b,sizeof(b))
#define rep(i,j,k) for(int i=(j);i<=(k);++i)
#define per(i,j,k) for(int i=(j);i>=(k);--i)
int read() {
    int a=0, f=1; char c=getchar();
    while(!isdigit(c)) {
        if(c=='-') f=-1;
        c=getchar();
    }
    while(isdigit(c)) a=a*10+c-'0', c=getchar();
    return a*f;
}
namespace IO{
    int c;
    unsigned int seed;
    unsigned int randnum(){
        seed^=seed<<13;
        seed^=seed>>17;
        seed^=seed<<5;
        return seed;
    }
    inline void init_case(int &m,int &a,int &b,int &d,int p[]){
        m=read();
        scanf("%u",&seed);
        a=read(), b=read(), c=read(), d=read();
        for(int i=1;i<=m;i++){
            if(randnum()%c==0) p[i]=-1;
            else p[i]=randnum()%b;
        }
    }

    inline void update_ans(unsigned int &ans_sum,int cur_ans,int no){
        const static unsigned int mod=998244353;
        ans_sum^=(long long)no*(no+7)%mod*cur_ans%mod;
    }
}
using IO::init_case;
using IO::update_ans;
const int N=2e6+5, mod=998244353;
int T, lim, m, a, b, d, p[N];
int buy[N], in[N], Q[N];
void solve() {
    uint ans=0u;
    init_case(m,a,b,d,p);
    lim=max(a,b)+1;
    rep(i,0,lim) buy[i]=in[i]=0;
    rep(i,0,a) buy[i]=in[i]=1;
    int l=1, r=0, pos=a+1;
    queue<int> q;
    rep(i,1,m) {
        if(p[i]==-1) {
            if(d||q.empty()) continue;
            if(Q[l]==q.front()) ++l;
            int x=q.front(); q.pop();
            in[x]=1;
        } else if(in[p[i]]) {
            if(d) continue;
            while(l<=r&&Q[r]>p[i]) --r;
            Q[++r]=p[i];
            in[p[i]]=0, q.push(p[i]);
        } else if(!buy[p[i]]) {
            buy[p[i]]=1, in[p[i]]=1;
            while(buy[pos]) ++pos;
        } else {
            if(d||q.empty()) continue;
            if(Q[l]==q.front()) ++l;
            int x=q.front(); q.pop();
            in[x]=1;
        }
        int res=pos;
        if(l<=r) res=min(res,Q[l]);
        update_ans(ans,res,i);
    }
    printf("%u\n",ans);
}
signed main() {
    T=read();
    while(T--) solve();
    return 0;
}
```




