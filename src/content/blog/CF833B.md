---
title: CF833B The Bakery 题解
pubDate: 2023-10-23
tags:
  - DP
  - 线段树
categories:
  - 题解
description: 'Solution'
---

## Solution

设 $f(i,j)$ 考虑序列前 $i$ 个元素，划分了 $j$  段的最大价值。

$$
f(i,j) = \max_{k \in [0,i-1]} \Big\{ f(k,j-1) + w(k+1,i) \Big\}
$$

貌似无法优化了。

求出 $a_i$ 上一次出现的 $pre_i$，所以它会 $[pre_i+1,i]$ 产生 $1$ 的贡献。

由于 $k \le 50$，我们不妨开 $k$ 棵线段树。借用扫描线的思想，第 $j$ 棵线段树的位置 $i$ 维护 $f(i-1,j)+w(i,i')$，其中 $i'$ 是当前扫到的位置。这样每个元素的贡献就是一个区间修改，求解一个 $f(i,j)$ 也变成了查询区间最大值，然后让第 $j$ 棵线段树的位置 $i+1$ 单点加上 $f(i,j)$ 即可。

复杂度 $O(nk \log n)$。

```cpp
#include<bits/stdc++.h> 
using namespace std;
#define int long long
#define uint unsigned long long
#define PII pair<int,int>
#define MP make_pair
#define fi first
#define se second
#define pb push_back
#define eb emplace_back
#define SET(a,b) memset(a,b,sizeof(a))
#define CPY(a,b) memcpy(a,b,sizeof(b))
#define rep(i,j,k) for(int i=(j);i<=(k);++i)
#define per(i,j,k) for(int i=(j);i>=(k);--i)
int read() {
    int a=0, f=1; char c=getchar();
    while(!isdigit(c)) {
        if(c=='-') f=-1;
        c=getchar();
    }
    while(isdigit(c)) a=a*10+c-'0', c=getchar();
    return a*f;
}
const int N=35005, M=51;
int n, m, a[N], pre[N], lst[N];
int f[M][N];
struct SegmentTree {
    int t[N<<2], tag[N<<2];
    void pushup(int x) { t[x]=max(t[x<<1],t[x<<1|1]); }
    void maketag(int x,int d) {
        t[x]+=d;
        tag[x]+=d;
    }
    void pushdown(int x) {
        if(tag[x]!=0) {
            maketag(x<<1,tag[x]);
            maketag(x<<1|1,tag[x]);
            tag[x]=0;
        }
    }
    void upd(int L,int R,int d,int x=1,int l=1,int r=n) {
        if(L<=l&&r<=R) { maketag(x,d); return; }
        pushdown(x);
        int mid=(l+r)>>1;
        if(L<=mid) upd(L,R,d,x<<1,l,mid);
        if(R>mid) upd(L,R,d,x<<1|1,mid+1,r);
        pushup(x);
    }
    int query(int L,int R,int x=1,int l=1,int r=n) {
        if(L<=l&&r<=R) return t[x];
        pushdown(x);
        int mid=(l+r)>>1, res=0;
        if(L<=mid) res=max(res,query(L,R,x<<1,l,mid));
        if(R>mid) res=max(res,query(L,R,x<<1|1,mid+1,r));
        return res;
    }
} T[M];
signed main() {
    n=read(), m=read();
    rep(i,1,n) {
        a[i]=read();
        pre[i]=lst[a[i]];
        lst[a[i]]=i;
    }
    for(int i=1;i<=n;++i) {
        for(int j=1;j<=m;++j) {
            T[j].upd(pre[i]+1,i,1);
            if(j==1) {
                f[1][i]=f[1][i-1]+(pre[i]==0);
                if(i<n) T[1].upd(i+1,i+1,f[1][i]);
                continue;
            }
            if(i>1)f[j][i]=T[j-1].query(j-1,i);
            if(i<n) T[j].upd(i+1,i+1,f[j][i]);
        }
    }
    printf("%lld\n",f[m][n]);
    return 0;
}
```
