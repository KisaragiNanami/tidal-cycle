---
title: AT2558 Many Moves 题解
tags:
  - DP
  - 线段树
categories:
  - 题解
pubDate: 2022-06-11
description: 'Solution'
---

## Solution

考虑完成 $i$ 个操作时，一定有一个棋子在 $x_i$ 的位置。4设 $f(i,j)$ 为完成了前 $i$ 个操作，其中另一个棋子的位置在 $j$。

转移显然有两种：

1. 把在 $x_{i-1}$ 的棋子移动到 $x_i$。
2. 把在某个位置 $j$ 的棋子移动到 $x_i$。

第一种转移是平凡的。

$$
f(i,j) = f(i-1,j) + |x_i - x_{i-1}|
$$



对于第二种转移，我们发现此时另一个棋子的位置一定是 $x_{i-1}$，所以

$$
f(i,x_{i-1}) = \min_{j=1}^n \Big \{ f(i-1,j) + |x_i-j| \Big \}
$$

套路性的把绝对值拆开

$$
f(i,x_{i-1}) = \begin{cases}f(i-1,j) - j + x_i & j \le x_i
\\
f(i-1,j) + j - x_i & j > x_i\end{cases}
$$

发现转移的本质比较简单，考虑把 $j$ 这一维拍到线段树上维护。

线段树上每个叶子节点维护 $f(j)$，$f(j)-j$，$f(j)+j$ 三个值，然后维护区间最小值。

第一种转移就是全局加法，第二种转移就是查询区间最小值然后单点取 $\min$。

复杂度 $O(Q \log_2 n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define uint unsigned long long
#define PII pair<int,int>
#define MP make_pair
#define fi first
#define se second
#define pb push_back
#define eb emplace_back
#define SET(a,b) memset(a,b,sizeof(a))
#define CPY(a,b) memcpy(a,b,sizeof(b))
#define rep(i,j,k) for(int i=(j);i<=(k);++i)
#define per(i,j,k) for(int i=(j);i>=(k);--i)
int read() {
    int a=0, f=1; char c=getchar();
    while(!isdigit(c)) {
        if(c=='-') f=-1;
        c=getchar();
    }
    while(isdigit(c)) a=a*10+c-'0', c=getchar();
    return a*f;
}
const int N=2e5+5, inf=0x0f0f0f0f0f0f0f0f;
int n, m, A, B, x[N];
int t[N<<2][3], tag[N<<2];
void pushup(int x) {
    t[x][0]=min(t[x<<1][0],t[x<<1|1][0]);
    t[x][1]=min(t[x<<1][1],t[x<<1|1][1]);
    t[x][2]=min(t[x<<1][2],t[x<<1|1][2]);
}
void maketag(int x,int d) {
    t[x][0]+=d;
    t[x][1]+=d;
    t[x][2]+=d;
    tag[x]+=d;
}
void pushdown(int x) {
    if(tag[x]!=0) {
        maketag(x<<1,tag[x]);
        maketag(x<<1|1,tag[x]);
        tag[x]=0;
    }
}
void build(int x=1,int l=1,int r=n) {
    tag[x]=0;
    t[x][0]=t[x][1]=t[x][2]=inf;
    if(l==r) return;
    int mid=(l+r)>>1;
    build(x<<1,l,mid);
    build(x<<1|1,mid+1,r);
//    pushup(x);
}
void upd(int L,int R,int d,int x=1,int l=1,int r=n) {
    if(L<=l&&r<=R) { maketag(x,d); return; }
    int mid=(l+r)>>1;
    pushdown(x);
    if(L<=mid) upd(L,R,d,x<<1,l,mid);
    if(R>mid) upd(L,R,d,x<<1|1,mid+1,r);
    pushup(x);
}
int query(int L,int R,int op,int x=1,int l=1,int r=n) {
    if(L<=l&&r<=R) return t[x][op];
    int mid=(l+r)>>1, res=inf;
    pushdown(x);
    if(L<=mid) res=min(res,query(L,R,op,x<<1,l,mid));
    if(R>mid) res=min(res,query(L,R,op,x<<1|1,mid+1,r));
    return res;
}
void mdf(int p,int d,int x=1,int l=1,int r=n) {
    if(l==r) {
        t[x][0]=min(t[x][0],d);
        t[x][1]=min(t[x][1],d-l);
        t[x][2]=min(t[x][2],d+l);
        return;
    }
    pushdown(x);
    int mid=(l+r)>>1;
    if(p<=mid) mdf(p,d,x<<1,l,mid);
    else mdf(p,d,x<<1|1,mid+1,r);
    pushup(x);
}
signed main() {
    n=read(), m=read(), A=read(), B=read();
    rep(i,1,m) x[i]=read();
    build();
    mdf(B,abs(x[1]-A));
    mdf(A,abs(x[1]-B));
    rep(i,2,m) {
        int dlt=abs(x[i]-x[i-1]);
        int tl=query(1,x[i],1)+x[i];
        int tr=inf;
        if(x[i]+1<=n) tr=query(x[i]+1,n,2)-x[i];
        upd(1,n,dlt);
        mdf(x[i-1],min(tl,tr));
    }
    printf("%lld\n",t[1][0]);
    return 0;
}
```
