---
title: LOJ3212 「CSP-S 2019」 划分 题解
pubDate: 2023-10-23
tags:
  - DP
  - 决策单调性
  - 单调队列
categories: 题解
description: 'Solution'
---

## Solution

容易想到一个暴力 DP。设 $f(i)$ 为划分 $[1,i]$ 的最小代价，记录取到最小值时的决策点 $g_i$ 即可转移。

设 $S_i = \sum_{j=1}^i a_j$，则

$$
f(i) = \min_{j \in [0,i-1] \land \text{valid}(j,i)} \Big\{ f(j)+ \Big(S_i - S_j \Big)^2\Big\}
$$



其中 $\text{valid}(j,i)=[S_i - S_j \ge S_j - S_{g_j}]$。

注意到 $(a+b)^2 = a^2 + 2ab + b^2$，那么尽可能多地划分必然不劣，从而这个 DP 有决策单调性。

更进一步地，最优决策一定是最大的 $j$，满足 $S_i - S_j \ge S_j -S_{g_j}$，移项得到 $S_i \ge 2S_j - S_{g_j}$，不妨设 $h(j) = 2S_j - S_{g_j}$。

这个值不一定是单调的，但是考虑对于一个 $j' < j$，如果 $h(j') \ge h(j)$，那么 $j'$ 就是无用决策。同时决策集合在序列上单调增大，所以用单调队列维护这个二维偏序关系的最优解即可。

时间复杂度 $O(n)$。





下面的代码只能拿到 $\text{88 pts}$。



```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define uint unsigned long long
#define PII pair<int,int>
#define MP make_pair
#define fi first
#define se second
#define pb push_back
#define eb emplace_back
#define SET(a,b) memset(a,b,sizeof(a))
#define CPY(a,b) memcpy(a,b,sizeof(b))
#define rep(i,j,k) for(int i=(j);i<=(k);++i)
#define per(i,j,k) for(int i=(j);i>=(k);--i)
int read() {
    int a=0, f=1; char c=getchar();
    while(!isdigit(c)) {
        if(c=='-') f=-1;
        c=getchar();
    }
    while(isdigit(c)) a=a*10+c-'0', c=getchar();
    return a*f;
}
const int N=1e6+5;
int n, type, s[N], f[N], g[N];
int q[N];
int squ(int x) { return x*x; }
int calc(int x) { return 2*s[x]-s[g[x]]; }
signed main() {
    n=read(), type=read();
    if(type) return 0;
    rep(i,1,n) s[i]=s[i-1]+read();
    int l=1, r=0;
    q[++r]=0;
    rep(i,1,n) {
        while(l<r&&calc(q[l+1])<=s[i]) ++l;
        g[i]=q[l], f[i]=f[g[i]]+squ(s[i]-s[g[i]]);
        while(l<r&&calc(q[r])>=calc(i)) --r;
        q[++r]=i;
    }
    printf("%lld\n",f[n]);
    return 0;
}
```
