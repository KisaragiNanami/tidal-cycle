---
title: CF1209E Rotate Columns 题解
pubDate: 2023-11-09
tags:
  - DP
  - 状态压缩
categories: 题解

---

## Solution

注意到答案的下界是每一列的最大值取前 $n$ 个，把这 $n$ 列提取出来，要考虑的数只有 $O(n^2)$ 个了。

然而最值是有后效性的东西，无法贪心解决，除了对每一列的循环移位状态进行搜索之外，似乎没有好的解决办法。

尝试这个后效性进一步剖析：后来的较小值会被先前的较大值所覆盖。也就是说我们容易得到一个状态的下界，但难以确定这个状态的上界，这种情况只会发生在我们把后来的这个值当作最大值时。如何避免呢？注意到 $n$ 很小，我们可以尝试一列一列地确定每一行的最大值，用一个二进制数表示被确定最大值的行的集合。这样每个“最大值”都是钦定出来的，如果一个状态错误地确定了一个局面，那么一定存在另一种状态能正确地刻画之，并且后者绝对比前者更加优秀。

设 $f(i,S)$ 为确定了前 $i$ 列，已经钦定了最值的行集合为 $S$ 时的最大收益。转移枚举当前列新确定的行集合 $S_0$，求出 $w(S_0)$ 表示通过循环移位使得当前列在 $S$ 中对应值之和的最大值，这个可以预处理。然后就可以枚举子集来转移。

复杂度 $O(T n 3^n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define uint unsigned long long
#define PII pair<int,int>
#define MP make_pair
#define fi first
#define se second
#define pb push_back
#define eb emplace_back
#define SET(a,b) memset(a,b,sizeof(a))
#define CPY(a,b) memcpy(a,b,sizeof(b))
#define rep(i,j,k) for(int i=(j);i<=(k);++i)
#define per(i,j,k) for(int i=(j);i>=(k);--i)
int read() {
    int a=0, f=1; char c=getchar();
    while(!isdigit(c)) {
        if(c=='-') f=-1;
        c=getchar();
    }
    while(isdigit(c)) a=a*10+c-'0', c=getchar();
    return a*f;
}
const int N=12, M=2005;
int T, n, m, U, a[N+5][M], b[N+5][N+5];
int f[M][1<<N], w[1<<N];
PII row[M];
int trans(int S) {
    int op=S&1;
    return (S>>1)|(op*(1<<(n-1)));
}
void solve() {
    n=read(), m=read();
    rep(i,1,n) rep(j,1,m) a[i][j]=read();
    rep(j,1,m) {
        int mx=0;
        rep(i,1,n) mx=max(mx,a[i][j]);
        row[j]=MP(mx,j); 
    }
    sort(row+1,row+m+1,greater<PII >());
    m=min(n,m);
    U=(1<<n)-1;
    rep(j,1,m) {
        int k=row[j].se;
        rep(i,1,n) b[i][j]=a[i][k];
    }
    f[0][0]=0;
    rep(i,1,m) {
        rep(S,0,U) {
            f[i][S]=0;
            w[S]=0;
            int S0=S;
            do {
                int s=0;
                for(int j=0;j<n;++j) if((S0>>j)&1) s+=b[j+1][i];
                w[S]=max(w[S],s);
                S0=trans(S0);
            } while(S0!=S);
        }
        rep(S,0,U) {
            for(int T=S;T;T=(T-1)&S) {
                f[i][S]=max(f[i][S],f[i-1][T]+w[S^T]);
            }
            f[i][S]=max(f[i][S],f[i-1][0]+w[S]);
        }
    }
    printf("%lld\n",f[m][U]);
}
signed main() {
    T=read();
    while(T--) solve();
    return 0;
}

```
