---
title: LOJ#3381 函数调用 题解
tags:
  - 图论
  - 拓扑排序
categories: 题解
pubDate: 2022-08-20
description: 'Solution'
---





## Solution

函数调用，满足不出现递归，本身就构成了一张 DAG。

由于乘法操作是全局乘法，所以可以把对函数 $i$ 贡献拆为两种：

1. 初始值与所有全局乘法的值之积。
2. 每一个作用在 $i$ 上的加法函数，要加上的值与其之后执行的全局乘法的值之积。

二者求和就是答案。

对于函数 $i$ 要调用的函数 $x$，连边 $(i \rightarrow x)$。

- 用 $\text{DFS}$ 可以处理出只运行函数 $i$ 时，全局乘上的值 $mul_i$。
- 用拓扑排序可以求出函数 $i$ 执行完之后又被乘上的值 $cnt_i$。

新建立一个节点 $0$，向所有初始被调用的函数连边。

下面说一下拓扑排序的细节。

为啥要拓扑排序呢？显然如果有边  $(x \rightarrow y)$，那么 $cnt_y$ 肯定是依赖于 $cnt_x$ 的。

然后对于另一条边 $(x \rightarrow y')$，钦定先调用 $y'$，那么 $cnt_{y'}$ 又会依赖于 $cnt_y$。如果用`std::vector`存图的话，直接倒着遍历，顺便维护乘积就行了。

```cpp
// Problem: P7077 [CSP-S2020] 函数调用
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P7077
// Author: KisaragiQwQ
// Date: 2023-06-18 19:47:10
// Memory Limit: 256 MB
// Time Limit: 2000 ms
// 
// Let's Daze
// 
// Powered by CP Editor (https://cpeditor.org)

#include<bits/stdc++.h>
using namespace std;
#define int long long
#define uint unsigned long long
#define PII pair<int,int>
#define MP make_pair
#define fi first
#define se second
#define pb push_back
#define eb emplace_back
#define SET(a,b) memset(a,b,sizeof(a))
#define CPY(a,b) memcpy(a,b,sizeof(b))
#define rep(i,j,k) for(int i=(j);i<=(k);++i)
#define per(i,j,k) for(int i=(j);i>=(k);--i)
int read() {
    int a=0, f=1; char c=getchar();
    while(!isdigit(c)) {
        if(c=='-') f=-1;
        c=getchar();
    }
    while(isdigit(c)) a=a*10+c-'0', c=getchar();
    return a*f;
}
const int N=1e5+5, mod=998244353;
int n, m, Q, a[N], type[N], in[N], id[N], pls[N], mul[N], cnt[N];
int v[N];
vector<int> p[N];
void dfs(int x) {
    if(v[x]) return;
    // 注意每个节点可能被多次访问，但是贡献只算一次
    v[x]=1;
    for(auto y:p[x]) {
        dfs(y);
        (mul[x]*=mul[y])%=mod;
    }
}
void toposort() {
    queue<int> q;
    rep(i,0,m) if(!in[i]) q.push(i);
    while(q.size()) {
        int x=q.front(); q.pop();
        int j=1;
        for(int i=(int)p[x].size()-1;~i;--i) {
            int y=p[x][i];
            (cnt[y]+=cnt[x]*j%mod)%=mod;
            (j*=mul[y])%=mod;
            if(--in[y]==0) q.push(y);
        }
    }
}
signed main() {
    freopen("call.in","r",stdin);
    freopen("call.out","w",stdout);
    n=read();
    rep(i,1,n) a[i]=read();
    m=read();
    rep(i,1,m) {
        type[i]=read();
        if(type[i]==1) id[i]=read(), pls[i]=read(), mul[i]=1;
        else if(type[i]==2) mul[i]=read();
        else {
            mul[i]=1;
            int C=read();
            while(C--) {
                int x=read();
                p[i].eb(x), ++in[x];
            }
        }
    }
    Q=read();
    rep(i,1,Q) {
        int x=read();
        p[0].pb(x), ++in[x];
    }
    cnt[0]=mul[0]=1;
    dfs(0);
    toposort();
    rep(i,1,n) (a[i]*=mul[0])%=mod;
    rep(i,1,m) if(type[i]==1) (a[id[i]]+=pls[i]*cnt[i]%mod)%=mod;
    rep(i,1,n) printf("%lld ",a[i]);
    return 0;
}
```
