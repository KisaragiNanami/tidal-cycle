---
title: CF1788E Sum Over Zero 题解
pubDate: 2023-11-10 10:22:48
tags:
  - DP
  - 二维偏序
categories:
  - 题解
description: 'Solution'
---

## Solution

区间直接差分掉。

设 $f(i)$ 表示考虑 $[1,i]$ 且选择了包含 $i$ 的一个区间的最大收益，有

$$
f(i) = \max_{j=1 \land s_i \ge s_{j-1}}^{i-1} \Big\{ f(j-1)+i-j+1 \Big\}
$$



典型的二维偏序问题。

把前缀和数组离散化，用 BIT 维护最大值，求出 $f(i)$ 后在 $s_i$ 处插入 $f(i)-i$ 即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define uint unsigned long long
#define PII pair<int,int>
#define MP make_pair
#define fi first
#define se second
#define pb push_back
#define eb emplace_back
#define SET(a,b) memset(a,b,sizeof(a))
#define CPY(a,b) memcpy(a,b,sizeof(b))
#define rep(i,j,k) for(int i=(j);i<=(k);++i)
#define per(i,j,k) for(int i=(j);i>=(k);--i)
int read() {
    int a=0, f=1; char c=getchar();
    while(!isdigit(c)) {
        if(c=='-') f=-1;
        c=getchar();
    }
    while(isdigit(c)) a=a*10+c-'0', c=getchar();
    return a*f;
}
const int N=2e5+5, inf=1e15;
int n, a[N], f[N];
int s[N];
int m, t[N];
struct BIT {
    int c[N];
    void init() { rep(i,1,n) c[i]=-inf; }
    void upd(int x,int y) {
        for(;x<=n;x+=x&-x) c[x]=max(c[x],y);
    }
    int query(int x) {
        int y=-inf;
        for(;x;x-=x&-x) y=max(y,c[x]);
        return y;
    }
} bit;
void lsh() {
    sort(t+1,t+m+1);
    m=unique(t+1,t+m+1)-(t+1);
    rep(i,0,n) s[i]=lower_bound(t+1,t+m+1,s[i])-t;
}
signed main() {
    n=read();
    rep(i,1,n) {
        a[i]=read(), s[i]=s[i-1]+a[i];
        t[++m]=s[i];
    }
    lsh();
    bit.init();
    rep(i,0,n) {
        if(t[s[i]]>=0) f[i]=i;
        int k=bit.query(s[i])+i;
        f[i]=max(f[i],k);
        if(i>0) f[i]=max(f[i],f[i-1]);
        bit.upd(s[i],f[i]-i);
    }
    printf("%lld\n",f[n]);
    return 0;
}
```
