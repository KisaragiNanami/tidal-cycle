---
title: CF1110F Nearest Leaf 题解
pubDate: 2023-10-23
tags:
  - DP
  - 树形DP
  - 换根法
  - 线段树
categories: 题解
description: 'Solution'
---

## Solution

静态问题，把询问离线了挂到节点上。

直接 $\text{DFS}$ 似乎难以解决。不妨考虑以每个询问中的 $x$ 为根的情况，此时的问题相当简单，然而复杂度是 $O(n^2)$ 的。

能发现以每个点为根的过程中，不会产生新的叶子。大胆地考虑使用换根法，对于一条树边 $(x,y)$，分别以二者为根的情况仅仅相差一条边，设其权值为 $z$。更进一步地，以 $x$ 为根时 $y$ 的子树中的叶子权值要 $-z$，其余要 $+z$。

把叶子拍到以 $1$ 为根的 $\text{DFS}$ 序上，做减法的叶子是一段区间，做加法的叶子是前缀和后缀，询问区间 $\min$。线段树即可维护。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define uint unsigned long long
#define PII pair<int,int>
#define MP make_pair
#define fi first
#define se second
#define pb push_back
#define eb emplace_back
#define SET(a,b) memset(a,b,sizeof(a))
#define CPY(a,b) memcpy(a,b,sizeof(b))
#define rep(i,j,k) for(int i=(j);i<=(k);++i)
#define per(i,j,k) for(int i=(j);i>=(k);--i)
int read() {
    int a=0, f=1; char c=getchar();
    while(!isdigit(c)) {
        if(c=='-') f=-1;
        c=getchar();
    }
    while(isdigit(c)) a=a*10+c-'0', c=getchar();
    return a*f;
}
const int N=5e5+5, inf=7e18;
int n, Q, d[N], lim[N], ans[N];
bool isl[N];
vector<PII > p[N];
struct node {
    int id, l, r;
    node() {}
    node(int a,int b,int c) { id=a, l=b, r=c; }
};
vector<node> q[N];
void dfs(int x) {
    lim[x]=x;
    if(p[x].size()==0) isl[x]=1;
    for(auto t:p[x]) {
        int y=t.fi, z=t.se;
        d[y]=d[x]+z;
        dfs(y);
        lim[x]=max(lim[x],lim[y]);
    }
}
int t[N<<2], tag[N<<2];
void pushup(int x) { t[x]=min(t[x<<1],t[x<<1|1]); }
void maketag(int x,int d) {
    t[x]+=d;
    tag[x]+=d;
}
void pushdown(int x) {
    if(tag[x]!=0) {
        maketag(x<<1,tag[x]);
        maketag(x<<1|1,tag[x]);
        tag[x]=0;
    }
}
void build(int x=1,int l=1,int r=n) {
    if(l==r) { if(isl[l]) t[x]=d[l]; else t[x]=inf; return; }
    int mid=(l+r)>>1;
    build(x<<1,l,mid);
    build(x<<1|1,mid+1,r);
    pushup(x);
}
void upd(int L,int R,int d,int x=1,int l=1,int r=n) {
    if(L<=l&&r<=R) { maketag(x,d); return; }
    int mid=(l+r)>>1;
    pushdown(x);
    if(L<=mid) upd(L,R,d,x<<1,l,mid);
    if(R>mid) upd(L,R,d,x<<1|1,mid+1,r);
    pushup(x);
}
int query(int L,int R,int x=1,int l=1,int r=n) {
    if(L<=l&&r<=R) return t[x];
    int mid=(l+r)>>1, res=inf;
    pushdown(x);
    if(L<=mid) res=min(res,query(L,R,x<<1,l,mid));
    if(R>mid) res=min(res,query(L,R,x<<1|1,mid+1,r));
    return res;
}
void dfs2(int x) {
    for(auto t:q[x]) {
        int i=t.id, l=t.l, r=t.r;        
        ans[i]=query(l,r);
    }
    for(auto t:p[x]) {
        int y=t.fi, z=t.se;
        upd(y,lim[y],-z);
        if(y-1>=1) upd(1,y-1,z);
        if(lim[y]+1<=n) upd(lim[y]+1,n,z);
        dfs2(y);
        upd(y,lim[y],z);
        if(y-1>=1) upd(1,y-1,-z);
        if(lim[y]+1<=n) upd(lim[y]+1,n,-z);
    }
}
signed main() {
    n=read(), Q=read();
    rep(i,2,n) {
        int x=read(), z=read();
        if(i>x) p[x].pb({i,z});
        else p[i].pb({x,z});
    }
    rep(i,1,Q) {
        int x=read(), l=read(), r=read();
        q[x].pb(node(i,l,r));
    }
    dfs(1);
    build();
    dfs2(1);
    rep(i,1,Q) printf("%lld\n",ans[i]);
    return 0;
}
```
