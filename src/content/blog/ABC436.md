---
title: AtCoder Beginner Contest 436
tags:
  - 贪心
  - 计数
  - 最短路
  - 图论
categories:
  - 比赛
  - atcoder
pubDate: 2025-12-14
description: '个人题解'
---
## A

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define uint unsigned long long
#define PII pair<int,int>
#define MP make_pair
#define fi first
#define se second
#define pb push_back
#define eb emplace_back
#define SET(a,b) memset(a,b,sizeof(a))
#define CPY(a,b) memcpy(a,b,sizeof(b))
#define rep(i,j,k) for(int i=(j);i<=(k);++i)
#define per(i,j,k) for(int i=(j);i>=(k);--i)
int read() {
   int a=0, f=1; char c=getchar();
   while(!isdigit(c)) {
       if(c=='-') f=-1;
       c=getchar();
   }
   while(isdigit(c)) a=a*10+c-'0', c=getchar();
   return a*f;
}
int n;
string s;
signed main() {
    cin >> n >> s;
    while(s.size() < n) s = 'o' + s;
    cout << s << endl;
    return 0;
}
```

## B

模拟即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define uint unsigned long long
#define PII pair<int,int>
#define MP make_pair
#define fi first
#define se second
#define pb push_back
#define eb emplace_back
#define SET(a,b) memset(a,b,sizeof(a))
#define CPY(a,b) memcpy(a,b,sizeof(b))
#define rep(i,j,k) for(int i=(j);i<=(k);++i)
#define per(i,j,k) for(int i=(j);i>=(k);--i)
int read() {
   int a=0, f=1; char c=getchar();
   while(!isdigit(c)) {
       if(c=='-') f=-1;
       c=getchar();
   }
   while(isdigit(c)) a=a*10+c-'0', c=getchar();
   return a*f;
}
const int N = 105;
int n, a[N][N];
void dfs(int x, int y, int k) {
    if(k >= n * n) return;
    int dx = (x - 1 + n) % n, dy = (y + 1) % n;
    if(!a[dx][dy]) {
        a[dx][dy] = k + 1;
        dfs(dx, dy, k + 1);
    } else {
        dx = (x + 1) % n, dy = y;
        a[dx][dy] = k + 1;
        dfs(dx, dy, k + 1);
    }
}
signed main() {
    cin >> n;
    a[0][(n - 1) / 2] = 1;
    dfs(0, (n - 1) / 2, 1);
    for(int i = 0;i < n;i++)  {
        for(int j = 0;j < n;j++) cout << a[i][j] << " ";
        puts(" ");
    }
    return 0;
}
```

## C

做麻烦了，用`std::set`维护一下二元组就行。

```cpp

#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define uint unsigned long long
#define PII pair<int,int>
#define MP make_pair
#define fi first
#define se second
#define pb push_back
#define eb emplace_back
#define SET(a,b) memset(a,b,sizeof(a))
#define CPY(a,b) memcpy(a,b,sizeof(b))
#define rep(i,j,k) for(int i=(j);i<=(k);++i)
#define per(i,j,k) for(int i=(j);i>=(k);--i)
int read() {
   int a=0, f=1; char c=getchar();
   while(!isdigit(c)) {
       if(c=='-') f=-1;
       c=getchar();
   }
   while(isdigit(c)) a=a*10+c-'0', c=getchar();
   return a*f;
}
const int N = 2e5 + 5;
int n, m, t, lst[N];
map<int, bool> p[N];
bool v[N];
map<int, int> mp;
PII a[N];
signed main() {
    ios::sync_with_stdio(0);
    cin >> n >> m;
    for(int i = 1;i <= m;i++) {
        cin >> a[i].fi >> a[i].se;
        if(!mp.count(a[i].fi)) mp[a[i].fi] = ++t;
    }
    int ans = 1;
    p[mp[a[1].fi]][a[1].se] = 1;
    for(int i = 2;i <= m;i++) {
        if(p[mp[a[i].fi]].count(a[i].se) || p[mp[a[i].fi]].count(a[i].se - 1) || p[mp[a[i].fi]].count(a[i].se + 1)) {
            continue;
        }
        if(mp.count(a[i].fi - 1)) if(p[mp[a[i].fi - 1]].count(a[i].se) || p[mp[a[i].fi - 1]].count(a[i].se - 1) || p[mp[a[i].fi - 1]].count(a[i].se + 1)) {
            continue;
        }
        if(mp.count(a[i].fi + 1)) if(p[mp[a[i].fi + 1]].count(a[i].se) || p[mp[a[i].fi + 1]].count(a[i].se - 1) || p[mp[a[i].fi + 1]].count(a[i].se + 1)) {
            continue;
        }
        ans++;
        p[mp[a[i].fi]][a[i].se] = 1;
    }
    cout << ans << endl;
    return 0;
}
```

## D

给每个字母建虚点，随便连一下边，跑最短路即可。

`Dijkstra`或`0-1 BFS`，因为从虚点到实点边权应该是`0`。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define uint unsigned long long
#define PII pair<int,int>
#define MP make_pair
#define fi first
#define se second
#define pb push_back
#define eb emplace_back
#define SET(a,b) memset(a,b,sizeof(a))
#define CPY(a,b) memcpy(a,b,sizeof(b))
#define rep(i,j,k) for(int i=(j);i<=(k);++i)
#define per(i,j,k) for(int i=(j);i>=(k);--i)
int read() {
   int a=0, f=1; char c=getchar();
   while(!isdigit(c)) {
       if(c=='-') f=-1;
       c=getchar();
   }
   while(isdigit(c)) a=a*10+c-'0', c=getchar();
   return a*f;
}
const int NN = 1e3 + 50, N = 1e6 + 50;
vector<int> p[N];
ll d[N];
int n, m, u;
string s[NN];
int id(int x, int y) {
    return (x - 1) * m + y;
}
void bfs() {
    deque<int> q;
    for(int i = 1;i <= u + 26;i++) d[i] = 1e18;
    d[1] = 0;
    q.push_back(1);
    while(q.size()) {
        int x = q.front();
        q.pop_front();
        for(auto y : p[x]) {
            if(x > u && y <= u) {
                if(d[y] > d[x]) {
                    d[y] = d[x];
                    q.push_front(y);
                }
            } else {
                if(d[y] > d[x] + 1) {
                    d[y] = d[x] + 1;
                    q.push_back(y);
                }
            }
            // printf("d[%d]=%d\n",y, d[y]);
        }
    }
}
signed main() {
    ios::sync_with_stdio(0);
    cin >> n >> m;
    for(int i = 1;i <= n;i++) {
        cin >> s[i];
        s[i] = " " + s[i];
    }
    u = n * m;
    for(int i = 1;i <= n;i++) for(int j = 1;j <= m;j++) {
        if(s[i][j] == '#') continue;
        if(i > 1 && s[i - 1][j] != '#') {
            p[id(i, j)].pb(id(i - 1, j));
        }
        if(j > 1 && s[i][j - 1] != '#') {
            p[id(i, j)].pb(id(i, j - 1));
        }
        if(i + 1 <= n && s[i + 1][j] != '#') {
            p[id(i, j)].pb(id(i + 1, j));
        }
        if(j + 1 <= m && s[i][j + 1] != '#') {
            p[id(i, j)].pb(id(i, j + 1));
        }
        if(s[i][j] != '.') {
            p[id(i, j)].pb(u + s[i][j] - 'a' + 1);
            p[u + s[i][j] - 'a' + 1].pb(id(i, j));
        }
    }
    bfs();
    if(d[u] < 1e18) cout << d[u] << endl;
    else puts("-1");
    return 0;
}
```

## E

关于这个交换，一开始笔者考虑的是逆序对，但有些交换并不能用「减少逆序对」来解释，交换能减少的逆序对数量也不可计算。对着样例手玩一下就能发现。

考虑连边 $(P_i \rightarrow i)$，我们就能得到一个有向图。拿样例举个例子

![3 1 4 2 5](https://s2.loli.net/2025/12/14/rDNl7i5aHnf49jK.png)

交换 $(1,2)$

![1 3 4 2 5](https://s2.loli.net/2025/12/14/7vbyhwEDZJUdSgB.png)!

或者交换 $(1,3)$

![4 1 3 2 5](https://s2.loli.net/2025/12/14/tubXZKdjowSf7C5.png)

或者交换 $(2,4)$

![3 2 4 1 5](https://s2.loli.net/2025/12/14/J56wXhEqWsNFARv.png)

交换 $(2,3)$

![3 4 1 2 5](https://s2.loli.net/2025/12/14/j5LfZUN7bqHzieQ.png)

在交换 $(1,2)$ 后，交换 $(2,4)$

![1 2 4 3 5](https://s2.loli.net/2025/12/14/mLMKlhVuCcw8D9H.png)

找到规律了。

这样每个非自环点都有且仅有一条出边和入边，于是形成了一个环。我们的目的是把所有环都变成自环。

交换 $(i,j)$，边就从 $(P_i \rightarrow i), (P_j \rightarrow j)$ 变成 $(P_i \rightarrow j), (P_j \rightarrow i)$，当 $P_i = j$ 或 $P_j = i$ 时，每成立一个就产生一个自环，相当于环上两个相邻的点挤出去一个。当二者均成立时，就是二元环的状态，这时候一次产生两个自环。最后一次操作必然是二元环的情况。

还有一种情况，如同交换 $(2,3)$，其实就是拎出去一个二元环，然后一次操作就能变成两个自环，不会对实际操作次数产生影响。

综合一下，就是大小为 $sz_i$ 的环，一定需要 $sz_i - 1$次操作。

假设一共有 $m$ 个环（包含自环），那么总的最少交换次数是 $\sum_{i = 1}^m sz_i - 1 = n - m$。

这种情况下，任何操作都是为了把大环拆小，于是我们第一次操作只需要选择同一大环上两个点即可（这样一定能产生自环或二元环），答案

$$
\sum_{i = 1}^m \binom{sz_i}{2}
$$

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define uint unsigned long long
#define PII pair<int,int>
#define MP make_pair
#define fi first
#define se second
#define pb push_back
#define eb emplace_back
#define SET(a,b) memset(a,b,sizeof(a))
#define CPY(a,b) memcpy(a,b,sizeof(b))
#define rep(i,j,k) for(int i=(j);i<=(k);++i)
#define per(i,j,k) for(int i=(j);i>=(k);--i)
int read() {
   int a=0, f=1; char c=getchar();
   while(!isdigit(c)) {
       if(c=='-') f=-1;
       c=getchar();
   }
   while(isdigit(c)) a=a*10+c-'0', c=getchar();
   return a*f;
}
const int N = 3e5 + 5;
int n, m, a[N], sz[N];
bool v[N];
vector<int> p[N];
void dfs(int x) {
    v[x] = 1;
    ++sz[m];
    for(auto y : p[x]) if(!v[y]) dfs(y);
}
signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin >> n;
    for(int i = 1;i <= n;i++) {
        int x;
        cin >> x;
        p[x].pb(i);
        p[i].pb(x);
    }
    for(int i = 1;i <= n;i++) {
        if(!v[i]) ++m, dfs(i);
    }
    ll ans = 0;
    for(int i = 1;i <= m;i++) {
        ans += 1ll * sz[i] * (sz[i] - 1) / 2;
    }
    cout << ans << endl;
    return 0;
}
```

## F

其实题目挺难读的。

乍一看可能和选择的区间有关，所以笔者先是考虑了分治。然而这显然是假的，因为数的是本质不同照片的数量。

考虑这样的照片有何性质：被拍到的星星在这段区间内的亮度排名必须是连续的。

枚举每个数作为最大值，那么我们就能忽略所有比它大的数（通过选择恰当的 $b$），然后就是计算此时本质不同区间的个数了。

设其为 $x$，左边有 $L$ 个数比它小，右边就有 $R = x - L - 1$ 个。能注意到给出的亮度序列是个排列。

那么本质不同照片个数就有

$$
(L + 1 ) \times (R + 1)
$$

从具体选进去的数考虑即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define uint unsigned long long
#define PII pair<int,int>
#define MP make_pair
#define fi first
#define se second
#define pb push_back
#define eb emplace_back
#define SET(a,b) memset(a,b,sizeof(a))
#define CPY(a,b) memcpy(a,b,sizeof(b))
#define rep(i,j,k) for(int i=(j);i<=(k);++i)
#define per(i,j,k) for(int i=(j);i>=(k);--i)
int read() {
   int a=0, f=1; char c=getchar();
   while(!isdigit(c)) {
       if(c=='-') f=-1;
       c=getchar();
   }
   while(isdigit(c)) a=a*10+c-'0', c=getchar();
   return a*f;
}
const int N = 5e5 + 5;
int n;
vector<int> a;
ll ans;
struct BIT {
    int c[N];
    void add(int x, int d) {
        for(int i = x;i <= n;i += i & -i) c[i] += d;
    }
    int sum(int x) {
        if(x == 0) return 0;
        int res = 0;
        for(int i = x;i;i -= i & -i) res += c[i];
        return res;
    }
} L;
signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin >> n;
    a.resize(n + 5);
    for(int i = 1;i <= n;i++) {
        cin >> a[i];
    }
    for(int i = 1;i <= n;i++) {
        int lt = L.sum(a[i]), rt = a[i] - 1 - lt;
        ans += 1ll * (lt + 1) * (rt + 1);
        L.add(a[i], 1);
    }
    cout << ans << endl;
    return 0;
}
```
