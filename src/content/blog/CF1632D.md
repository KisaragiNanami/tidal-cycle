---
title: CF1632D New Year Concert 题解
pubDate: 2023-11-08
tags:
  - 数论
  - 贪心
  - 决策单调性
categories:
  - 题解

---

## Solution

如果要改变一个数字，那么把它改成一个极大的质数一定是最优的。因为任何包含这个位置的区间都将不再非法。

更进一步的，如果我们能提取出所有的非法区间，那么就能将原问题转化为经典问题：选取最少的点，使得任意区间都至少包含一个点。做法就是区间按照右端点排序，如果当前区间内没有点，那么就在当前区间最后面放一个。

考虑更一般的做法。设 $f(i)$ 为前缀 $[1,i]$ 的最小代价， $g(l,r)=\gcd_{i=l}^r \{a_i\}$。

扫描右端点 $r$，不难发现此时有 $g(l,r)$ 关于 $l$ 单调不降，而此时 $len(l,r) = r-l+1$ 是关于 $l$  的线性函数，从而满足 $g(l,r) = r-l+1$ 的点一定连续，从而容易二分得到。

如果存在满足 $g(l,r)=len(l,r)$ 的一段，那么把 $a_r$ 改掉显然最优，同时下一次二分的下界就可以设置为 $r+1$。如果修改了 $a_r$，那么令 $f(i) = f(i-1)+1$，否则 $f(i) = f(i-1)$。

用 ST 表维护区间 $\gcd$，复杂度 $O(n \log n \log V)$。

注意到满足 $g(l,r)=len(l,r)$ 的临界点有决策单调性，维护一个指针即可做到 $O(n \log V)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define uint unsigned long long
#define PII pair<int,int>
#define MP make_pair
#define fi first
#define se second
#define pb push_back
#define eb emplace_back
#define SET(a,b) memset(a,b,sizeof(a))
#define CPY(a,b) memcpy(a,b,sizeof(b))
#define rep(i,j,k) for(int i=(j);i<=(k);++i)
#define per(i,j,k) for(int i=(j);i>=(k);--i)
int read() {
    int a=0, f=1; char c=getchar();
    while(!isdigit(c)) {
        if(c=='-') f=-1;
        c=getchar();
    }
    while(isdigit(c)) a=a*10+c-'0', c=getchar();
    return a*f;
}
const int N=2e5+5;
int n, a[N], f[N][19], lg[N], g[N];
int query(int l,int r) {
    if(l>r) return 0;
    int k=lg[r-l+1];
    return __gcd(f[l][k],f[r-(1<<k)+1][k]);
}
signed main() {
    n=read();
    rep(i,1,n) {
        a[i]=f[i][0]=read();
        if(i>1) lg[i]=lg[i>>1]+1;
    }
    for(int j=1;(1<<j)<=n;++j)
        for(int i=1;i+(1<<j)-1<=n;++i)
            f[i][j]=__gcd(f[i][j-1],f[i+(1<<(j-1))][j-1]);
    int pos=1;
    rep(i,1,n) {
        g[i]=g[i-1];
        while(pos<i&&query(pos,i)<i-pos+1) ++pos;
        if(pos<=i&&query(pos,i)==i-pos+1) ++g[i], pos=i+1;
        printf("%d ",g[i]);
    }
    return 0;
}
```


