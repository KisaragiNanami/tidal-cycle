---
title: LOJ#2331 某位歌姬的故事 题解
pubDate: 2023-09-07
tags:
  - DP
  - 计数
categories:
  - 题解
description: 'Solution'
---

## Solution

对于每个位置 $i$，我们维护一个 $up_i$ 表示 $i$ 能填入的上界。这样每个限制 $(l,r,x)$ 相当于让 $i \in [l,r]$ 的 $up_i$ 对 $x$ 取 $\min$。

继续分析限制，发现它其实限制了两点：

1. $\forall i \in [l,r]$，$a_i \le x$。
2. $\exists i \in [l,r]$，$a_i = x$。

$up_i$ 已经保证了第一点，考虑如何满足第二点。

对于一个限制 $(l,r,x)$，能取到 $w$ 的位置 $k$ 一定满足 $k \in [l,r]$ 并且 $up_k = x$。但我们计数的序列要求本质不同，所以不能“钦定一个 $a_k$ 取 $x$ 然后剩下的随便选”，否则会出现重复。

仔细思考不难发现，$up_i$ 不同的点是相对独立的。所以我们枚举每个 $x$，把所有 $up_i=x$ 的点提取出来，同时处理满足这些限制的方案数。



&nbsp;

注意，本来我们应该对于每个限制单独提取相应的点，但是这样需要维护区间信息，大大增加工作量。

&nbsp;



把坐标离散化了，设 $f(i,j)$ 为考虑了前 $i$ 个位置，其中上一个 $x$ 的位置在 $j$ 的方案数。转移比较平凡，不再赘述。

但是本题最难处理的地方在于细节，下面简单列举。

- 需要处理没有被限制区间覆盖到的点。

- 离散化后，DP 前提取的是限制的端点，真正有贡献的则是夹在端点间的点。

- 提取的点之间，就算是被同一个限制覆盖，也可能是不连续的。

- DP 转移时，如果要 $f(i-1,j) \rightarrow f(i,j)$，那么必须要求 $i-1$ 与 $i$ 在同一个限制区间里。

为了更好地处理区间边界问题，使用**左闭右开**。它的好处是离散化后任意两个坐标对应的值相减，都是区间内点的个数。

具体细节的处理见代码。

时间复杂度 $\mathcal{O} (Q^3)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define uint unsigned long long
#define PII pair<int,int>
#define MP make_pair
#define fi first
#define se second
#define pb push_back
#define eb emplace_back
#define SET(a,b) memset(a,b,sizeof(a))
#define CPY(a,b) memcpy(a,b,sizeof(b))
#define rep(i,j,k) for(int i=(j);i<=(k);++i)
#define per(i,j,k) for(int i=(j);i>=(k);--i)
int read() {
    int a=0, f=1; char c=getchar();
    while(!isdigit(c)) {
        if(c=='-') f=-1;
        c=getchar();
    }
    while(isdigit(c)) a=a*10+c-'0', c=getchar();
    return a*f;
}
const int N=1005;
const ll mod=998244353ll;
int T, n, q, A, up[N], L[N];
int cnt, t[N];
int cntx, x[N];
int lim, p[N];
ll f[N][N];
struct node {
    int l, r, x;
} a[N];
ll fp(int a,int b) {
    if(b<0) return 0;
    ll c=1;
    for(;b;a=1ll*a*a%mod,b>>=1) if(b&1) c=c*a%mod;
    return c;
}
ll DP(int k) {
    lim=0;
    rep(i,1,cnt) if(up[i]==k) p[++lim]=i, L[lim]=0;
    rep(i,1,q) if(a[i].x==k) {
        int l=lower_bound(p+1,p+lim+1,a[i].l)-p;
        int r=lower_bound(p+1,p+lim+1,a[i].r)-p-1;
        L[r]=max(L[r],l);
        // 维护限制区间内最靠右边的点，对应的最靠右的能覆盖到它的左端点
    }
    f[0][0]=1ll;
    for(int i=1;i<=lim;++i) {
        f[i][i]=0;
        ll k1=fp(k,t[p[i]+1]-t[p[i]]), k2=fp(k-1,t[p[i]+1]-t[p[i]]);
        // 如果端点p[i]被x=k的端点覆盖了，那么[p[i],p[i+1])中的点就一定满足up=k
        // k2是这一段的值都小于k的方案数
        // k1是这一段的值都不能超过k的方案数
        // 二者之差是至少存在一个k，都不能超过k的方案数
        for(int j=0;j<i;++j) {
            f[i][j]=0;
            if(L[i]<=j) f[i][j]=f[i-1][j]*k2%mod;
            // 如果i到达了某个限制区间最靠右的坐标，那么就必须要在这个限制区间内转移过来
            // i每次增加1，所以能保证正确性
            (f[i][i]+=f[i-1][j]*(k1-k2+mod)%mod)%=mod;
        }
    }
    ll res=0ll;
    for(int i=1;i<=lim;++i) (res+=f[lim][i])%=mod;
    return res; 
}
void clear() {
    cnt=cntx=0;
}
void input() {
    n=read(), q=read(), A=read();
    rep(i,1,q) {
        a[i].l=read(), a[i].r=read()+1, a[i].x=read();
        // 左闭右开
        t[++cnt]=a[i].l, t[++cnt]=a[i].r;
        x[++cntx]=a[i].x;
    }
}
void lsh() {
    t[++cnt]=1, t[++cnt]=n+1;
    // 需要加入端点
    sort(t+1,t+cnt+1);
    cnt=unique(t+1,t+cnt+1)-(t+1);
    rep(i,1,cnt) up[i]=1e9;
    rep(i,1,q) {
        a[i].l=lower_bound(t+1,t+cnt+1,a[i].l)-t;
        a[i].r=lower_bound(t+1,t+cnt+1,a[i].r)-t;
        for(int j=a[i].l;j<a[i].r;++j) up[j]=min(up[j],a[i].x);
        // 把范围内的端点都覆盖了，注意左闭右开
    }
    sort(x+1,x+cntx+1);
    cntx=unique(x+1,x+cntx+1)-(x+1);
}
void solve() {
    clear();
    input();
    lsh();
    ll ans=1ll;
    for(int i=1;i<=cntx;++i) {
        (ans*=DP(x[i]))%=mod;
        if(ans==0) { puts("0"); return; }
    }
    for(int i=1;i<cnt;++i) if(up[i]==1e9) {
        // 最后仍然没有被覆盖到的端点
        // 其实是某些右端点+1后的位置
        (ans*=fp(A,t[i+1]-t[i]))%=mod;
    }
    printf("%lld\n",ans);
}
signed main() {
    T=read();
    while(T--) solve();
    return 0;
}
```

## 题外话

有很多细节，很难写。

但是可以退而求其次，不离散化，用这个做法对付 $n \le 500$ 的测试点也是绰绰有余。

不愧是集训队的题目，真是令人印象深刻啊。
