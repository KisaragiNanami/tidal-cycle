---
title: CF803F Coprime Subsequences 题解
pubDate: 2023-11-08
tags:
  - DP
  - 数论
  - 计数
  - 莫比乌斯反演
categories: 题解
description: 'Solution'
---

## Solution

设 $f(n)$ 为存在公约数为 $n$ 的子序列数量，$g(n)$ 为 $\gcd=n$ 的子序列数量，有

$$
f(n) = \sum_{n \mid d} g(d)
$$

反演得到

$$
g(n) = \sum_{n \mid d} \mu\Big(\frac{d}{n}\Big) g(d)
$$

求 $g(1)$，随便做了。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define uint unsigned long long
#define PII pair<int,int>
#define MP make_pair
#define fi first
#define se second
#define pb push_back
#define eb emplace_back
#define SET(a,b) memset(a,b,sizeof(a))
#define CPY(a,b) memcpy(a,b,sizeof(b))
#define rep(i,j,k) for(int i=(j);i<=(k);++i)
#define per(i,j,k) for(int i=(j);i>=(k);--i)
int read() {
    int a=0, f=1; char c=getchar();
    while(!isdigit(c)) {
        if(c=='-') f=-1;
        c=getchar();
    }
    while(isdigit(c)) a=a*10+c-'0', c=getchar();
    return a*f;
}
const int N=1e5+5, mod=1e9+7;
int n, ans, lim, a[N], c[N], pw[N];
int cnt, p[N], mu[N];
bool v[N];
void getmu() {
    mu[1]=1;
    rep(i,2,lim) {
        if(!v[i]) p[++cnt]=i, mu[i]=-1;
        for(int j=1;j<=cnt&&i*p[j]<=lim;++j) {
            v[i*p[j]]=1;
            if(i%p[j]) {
                mu[i*p[j]]=-mu[i];
            } else {
                mu[i*p[j]]=0;
                break;
            }
        }
    }
}
signed main() {
    n=read();
    pw[0]=1;
    rep(i,1,n) a[i]=read(), lim=max(lim,a[i]), ++c[a[i]], pw[i]=pw[i-1]*2%mod;
    rep(i,1,lim) for(int j=2*i;j<=lim;j+=i) c[i]+=c[j];
    getmu();
    rep(i,1,lim) (ans+=(mu[i]+mod)%mod*(pw[c[i]]-1+mod)%mod)%=mod;
    printf("%lld\n",ans);
    return 0;
}

```
