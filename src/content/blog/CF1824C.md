---
title: CF1824C LuoTianyi and XOR-Tree 题解
pubDate: 2023-10-23
tags:
  - DP
  - 树形DP
  - 树论
  - 启发式合并
categories: 题解
description: 'Solution'
---

## Solution

考虑一个暴力。

设 $f(x,i)$ 为以 $x$ 为根的子树，每个叶子到 $x$ 的路径的点权异或和为 $i$ 时的最小代价。

对于 $f(x,i)$，不难发现只有当 $j = a_x \oplus i$ 时，$f(x,i) = f(y,j)$，否则 $f(x,i) = f(y,j')+1$，因此维护前缀后缀 $\min$ 即可做到 $O(n^2)$。

考虑一个性质。

如果 $f(y,j') > f(y,j)$，那么可以通过修改一个点的权值的方式使得 $j$ 变为 $j'$，同时 $f(y,j') \ge f(y,j)$。因此对 $x$ 有用的的只有满足 $f(y,j)$ 取到最小值的 $j$。

设这些 $j$ 构成的可重集合为 $G(x)$，容易发现最优决策就是取 $G(x)$ 中出现次数最多的 $j$。

如何维护 $G(x)$？本质上是叶子节点的信息集，用`std::map`维护，启发式合并即可，复杂度 $O(n \log^2 n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define uint unsigned long long
#define PII pair<int,int>
#define MP make_pair
#define fi first
#define se second
#define pb push_back
#define eb emplace_back
#define SET(a,b) memset(a,b,sizeof(a))
#define CPY(a,b) memcpy(a,b,sizeof(b))
#define rep(i,j,k) for(int i=(j);i<=(k);++i)
#define per(i,j,k) for(int i=(j);i>=(k);--i)
int read() {
    int a=0, f=1; char c=getchar();
    while(!isdigit(c)) {
        if(c=='-') f=-1;
        c=getchar();
    }
    while(isdigit(c)) a=a*10+c-'0', c=getchar();
    return a*f;
}
const int N=1e5+5;
int n, ans, a[N], id[N];
vector<int> p[N];
map<int,int> mp[N], s;
void dfs(int x,int fa) {
    if(fa&&p[x].size()==1) {
        mp[id[x]][a[x]]=1;
        return;
    }
    int cnt=0, mx=1;
    for(auto y:p[x]) if(y!=fa) {
        a[y]^=a[x];
        // 注意这里
        dfs(y,x);
        ++cnt;
        if(mp[id[x]].size()<mp[id[y]].size()) swap(id[x],id[y]);
        for(auto t:mp[id[y]]) {
            mp[id[x]][t.fi]+=t.se;
            mx=max(mx,mp[id[x]][t.fi]);
        }
        // 启发式合并
    }
    ans+=cnt-mx;
    if(mx>1) {
        s.clear();
        for(auto t:mp[id[x]]) {
            if(t.se==mx) s[t.fi]=1;
        }
        swap(s,mp[id[x]]);
        // 更新后map中元素数量总和至多为原来的一半
    }
}
signed main() {
    n=read();
    rep(i,1,n) a[i]=read(), id[i]=i;
    rep(i,2,n) {
        int x=read(), y=read();
        p[x].pb(y), p[y].pb(x);
    }
    dfs(1,0);
    printf("%lld\n",ans+(!mp[id[1]][0]));
    return 0;
}
```
