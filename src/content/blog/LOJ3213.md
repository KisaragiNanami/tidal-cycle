---
title: LOJ3213 「CSP-S 2019」 树的重心
pubDate: 2023-10-23
tags:
  - 树论
  - 树上倍增
  - 换根法
categories: 题解
description: 'Solution'
---

## Solution

大常数做法。

不妨先钦定 $1$ 为根。

一棵树最多有两个重心，且如果有两个，那么它们相邻。

$\mathbf{Lemma}$

> 对于一棵 $n$ 个节点的有根树 $T$，如果节点 $x$ 是 $T$ 的重心，那么 $x$ 在以 $\operatorname{root}(T)$ 为链头的重链上。

$\mathbf{Proof}$

> 归纳法。
> 
> 钦定根的深度为 $1$，考虑从根开始往下寻找重心的过程。
> 
> 当 $\operatorname{dep}(x) = 1$ 时，显然正确。
> 
> 设当前深度为 $d$，且 $\operatorname{dep}(x) > d$，那么说明深度为 $d$ 的这一层中有且仅有一棵大小超过 $\lfloor \frac{n}{2} \rfloor$ 的子树，根据重心的定义，$x$ 必然在这棵子树中，并且这棵子树的根一定是它的父节点的重儿子，因此必须往下一层的重链移动。

那么通过一遍 $\operatorname{DFS}$ 求出子树大小，每个节点的父节点和重儿子。这样我们就能快速找到一个重心 $x$，并且如果存在另一个重心，那么一定是 $x$ 的父亲或重儿子之一。

找重心的过程相当于从根不断往下跳重儿子，于是可以用倍增优化。

考虑如何维护断掉一条边分裂出的两棵树的信息。

其实就和换根差不多，在 $\operatorname{DFS}$ 的过程中维护信息，回溯时还原即可。

具体地，对于一条边 $(x,y)$，在搜到它的时候是为把这条边断开，分裂成以 $x$ 为根和以 $y$ 为根两棵子树，同时更新两个节点的信息。前者是一棵「倒」着的树，需要不断 $\operatorname{DFS}$ 扩展得到最新的信息，后者的信息就是第一次处理出来的，所以用 $y$ 和 $fa(x)$ 更新 $x$ 就行了。

注意 $y$ 可能在原树中是 $x$ 的重儿子，所以还要维护原树中次重儿子是哪个节点。

复杂度 $\mathcal{O}(n \log n)$，但是常数很大。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define uint unsigned long long
#define PII pair<int,int>
#define MP make_pair
#define fi first
#define se second
#define pb push_back
#define eb emplace_back
#define SET(a,b) memset(a,b,sizeof(a))
#define CPY(a,b) memcpy(a,b,sizeof(b))
#define rep(i,j,k) for(int i=(j);i<=(k);++i)
#define per(i,j,k) for(int i=(j);i>=(k);--i)
int read() {
    int a=0, f=1; char c=getchar();
    while(!isdigit(c)) {
        if(c=='-') f=-1;
        c=getchar();
    }
    while(isdigit(c)) a=a*10+c-'0', c=getchar();
    return a*f;
}
const int N=3e5+5;
int T, n, sz[N];
int son[N], son2[N], lg[N], f[N][19];
ll ans;
int tot, h[N], to[N<<1], nxt[N<<1];
void add(int x,int y) {
    to[++tot]=y, nxt[tot]=h[x], h[x]=tot;
}
void reset() {
    tot=ans=0;
    rep(x,1,n) son[x]=son2[x]=0, h[x]=0;
}
void dfs1(int x,int fa) {
    sz[x]=1;
    for(int i=h[x];i;i=nxt[i]) {
        int y=to[i];
        if(y==fa) continue;
        dfs1(y,x);
        sz[x]+=sz[y];
        if(sz[y]>sz[son[x]]) son2[x]=son[x], son[x]=y;
        else if(sz[y]>sz[son2[x]]) son2[x]=y;
    }
    f[x][0]=son[x];
    for(int i=1;i<=lg[n];++i) f[x][i]=f[f[x][i-1]][i-1];
}
int calc(int x) {
    int y=x;
    for(int i=lg[n];~i;--i) if(sz[f[y][i]]>sz[x]/2) y=f[y][i];
    int res=0;
    if(sz[x]-sz[y]<=sz[x]/2) res+=y;
    if(sz[x]-sz[f[y][0]]<=sz[x]/2) res+=f[y][0];
    return res;
}
void dfs2(int x,int fa) {
    int szx=sz[x], sonx=son[x];
    for(int i=h[x];i;i=nxt[i]) {
        int y=to[i];
        if(y==fa) continue;

        // cut the edge (x,y)
        son[x]=sonx;
        if(sonx==y) son[x]=son2[x];
        if(sz[fa]>sz[son[x]]) son[x]=fa;

        f[x][0]=son[x];
        for(int j=1;j<=lg[n];++j) f[x][j]=f[f[x][j-1]][j-1];

        sz[x]=n-sz[y];
        ans+=calc(x);
        ans+=calc(y);

        dfs2(y,x);
    }
    sz[x]=szx, f[x][0]=son[x]=sonx;
    for(int j=1;j<=lg[n];++j) f[x][j]=f[f[x][j-1]][j-1];
}
void solve() {
    n=read();
    rep(i,2,n) {
        int x=read(), y=read();
        add(x,y), add(y,x);
        lg[i]=lg[i>>1]+1;
    }
    dfs1(1,0);
    dfs2(1,0);
    printf("%lld\n",ans);
    reset();
}
signed main() {
    // freopen("centroid.in","r",stdin);
    // freopen("centroid.out","w",stdout);
    T=read();
    while(T--) solve();
    return 0;
}
```
