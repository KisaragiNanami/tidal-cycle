---
title: LOJ#2362「NOIP2016」蚯蚓 题解
pubDate: 2023-09-15
tags:
  - 数据结构
  - 单调队列
categories:
  - 题解
math: true
comment: true
---

## Solution

用大根堆维护所有蚯蚓，然后我们唯一要解决的就是每秒增加 $q$ 的问题。

对于这种一个集合不断有新值加入，整体每单位时间增加一个常数的问题，我们只需要维护一个变量 $tag$ 表示当前全局被加上的值，每个单位时间都累加 $q$。当我们加入一个新值时 $x$，只需要加入 $x-tag$，维护集合内部相对大小；取出时，把 $x+tag$ 作为它的真实值。

之后就是模拟取数的过程，最后从大到小输出堆内所有元素就行了。

然而当时的 NOIP 不开 O2 优化，用的也是 C++98 标准和老爷机，这样是跑不过去的。

注意到对于每次加入的 $\lfloor px \rfloor$，在任意时刻，先加入的必然不小于后加入的，$x - \lfloor px \rfloor$ 同理。

我们开三个队列，第一个维护从大到小排序的原序列，第二个维护每次加入的 $\lfloor px \rfloor$，第三个维护每次加入的 $x - \lfloor px \rfloor$。这样最大值永远是三个队头元素的最大值，复杂度优化到 $O(n+m)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define uint unsigned long long
#define PII pair<int,int>
#define MP make_pair
#define fi first
#define se second
#define pb push_back
#define eb emplace_back
#define SET(a,b) memset(a,b,sizeof(a))
#define CPY(a,b) memcpy(a,b,sizeof(b))
#define rep(i,j,k) for(int i=(j);i<=(k);++i)
#define per(i,j,k) for(int i=(j);i>=(k);--i)
int read() {
    int a=0, f=1; char c=getchar();
    while(!isdigit(c)) {
        if(c=='-') f=-1;
        c=getchar();
    }
    while(isdigit(c)) a=a*10+c-'0', c=getchar();
    return a*f;
}
const int N=1e5+5;
int n, m, q, u, v, t, tag, a[N];
double p;
queue<int> Q[3];
int getmax() {
    int res=-1e9, id=0;
    for(int i=0;i<3;++i) if(Q[i].size()&&Q[i].front()>res) res=Q[i].front(), id=i;
    Q[id].pop();
    return res;
}
signed main() {
    n=read(), m=read(), q=read(), u=read(), v=read(), t=read();
    p=1.0*u/v;
    rep(i,1,n) a[i]=read();
    sort(a+1,a+n+1,greater<int>());
    rep(i,1,n) Q[0].push(a[i]);
    for(int i=1;i<=m;++i) {
        int x=getmax()+tag;
        if(i%t==0) printf("%d ",x);
        int a=p*x, b=x-a;
        tag+=q;
        Q[1].push(a-tag), Q[2].push(b-tag);

    }
    puts("");
    for(int i=1;i<=n+m;++i) {
        int x=getmax()+tag;
        if(i%t==0) printf("%d ",x);
    }
    puts("");
    return 0;
}
```
